<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Mokking, Spying & Stabbing </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Mokking, Spying & Stabbing (ver 4.0.0) </h1>
    <p> Updated ( 2021-08-20 )</p>
    <p class="sitenav"> 
      <a href="../../index.html">MySite> </a> 
      <a href="../index.html">Jest> </a> Mokking, Spying & Stabbing
    </p>
<table class="table">
<caption>
    Mock Functions 
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method  </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td> 
        jest.fn(<i class="openable">fn<div>
          <p> - 'mock implementation', we can pass a function here which is ececuted when the mock function is called </p>
        </div></i>)
  </td>
  <td> 
      - creates and returns a <strong>mockFn</strong>, implements a mock function which returns <mark>undefined</mark> if not specified 
  </td>
</tr>
<tr class="05.02">
  <td> 
        jest.isMockFunction(<strong>fn</strong>)
  </td>
  <td> 
        - returns <mark>true</mark> if the passed <strong>fn</strong> is a mock function, <mark>false</mark> otherwise
  </td>
</tr>
<tr class="35.02">
  <td> 
        jest.clearAllMocks()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>all</u> mock functions in this scope 
  </td>
</tr>
<tr class="35.04">
  <td> 
        jest.resetAllMocks()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>all</u> mock functions in this scope <br>
      - also removes any mock function implementations 
  </td>
</tr>
<tr class="25.02">
  <td> 
        <strong>mockFn</strong>.getMockName()
  </td>
  <td> 
      - returns the <strong>mockFn</strong>'s name (which is displayed in failed tests)
  </td>
</tr>
<tr class="30.01">
  <td> 
        <strong>mockFn</strong>.mock.calls
  </td>
  <td> 
      - returns an Array in which each item is an Array containing the call arguments for each call (ex: <mark>[[1, 2], [5, 5]]</mark>)
  </td>
</tr>
<tr class="30.02">
  <td> 
        <strong>mockFn</strong>.mock.results
  </td>
  <td> 
      - returns an Array in which each item is an <strong class="openable">obj<div>
        <p> <mark>type: 'return|throw|incomplete'</mark> - contains the result type </p>
        <p> <mark>value: <strong>val</strong></mark> - contains the value of the call result </p>
      </div></strong> containing the results for each call (ex: <mark>[{type:return, value:3}, {type:'throw', value:'err'}]</mark>)
  </td>
</tr>
<tr class="35.01">
  <td> 
        <strong>mockFn</strong>.mockClear()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>this</u> mock function
  </td>
</tr>
<tr class="10.01">
  <td> 
        <strong>mockFn</strong>.mockImplementation(<strong>fn</strong>)
  </td>
  <td> 
      - overrides the mock implementation of <strong>mockFn</strong> 
  </td>
</tr>
<tr class="10.02">
  <td> 
        <strong>mockFn</strong>.mockImplementationOnce(<strong>fn</strong>)
  </td>
  <td> 
      - overrides the mock implementation of <strong>mockFn</strong> only once (expires when called once)
  </td>
</tr>
<tr class="25.01">
  <td> 
        <strong>mockFn</strong>.mockName(<strong>name:str</strong>)
  </td>
  <td> 
      - sets the <strong>mockFn</strong>'s name (which is displayed in failed tests) 
  </td>
</tr>
<tr class="20.03">
  <td> 
        <strong>mockFn</strong>.mockRejectedValue(<strong>val</strong>)
  </td>
  <td> 
      - sets the rejected value for a <strong>mockFn</strong> that returns a resolved promise 
  </td>
</tr>
<tr class="20.04">
  <td> 
        <strong>mockFn</strong>.mockRejectedValueOnce(<strong>val</strong>)
  </td>
  <td> 
      - sets the rejected value for a <strong>mockFn</strong> that returns a resolved promise only once (expires after the promise is resolved once)
  </td>
</tr>
<tr class="35.03">
  <td> 
        <strong>mockFn</strong>.mockReset()
  </td>
  <td> 
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark> of <u>this</u> mock function <br>
      - also removes any mock function implementations 
  </td>
</tr>
<tr class="20.01">
  <td> 
        <strong>mockFn</strong>.mockResolvedValue(<strong>val</strong>)
  </td>
  <td> 
      - sets the resolved value for a <strong>mockFn</strong> that returns a resolved promise 
  </td>
</tr>
<tr class="20.02">
  <td> 
        <strong>mockFn</strong>.mockResolvedValueOnce(<strong>val</strong>)
  </td>
  <td> 
      - sets the resolved value for a <strong>mockFn</strong> that returns a resolved promise only once (expires after the promise is resolved once)
  </td>
</tr>
<tr class="15.03">
  <td> 
        <strong>mockFn</strong>.mockReturnThis()
  </td>
  <td> 
      - returns the <mark>this</mark> value of the <strong>mockFn</strong> 
  </td>
</tr>
<tr class="15.01">
  <td> 
        <strong>mockFn</strong>.mockReturnValue(<strong>val</strong>)
  </td>
  <td> 
      - sets the mock function's return value 
  </td>
</tr>
<tr class="15.02">
  <td> 
        <strong>mockFn</strong>.mockReturnValueOnce(<strong>val</strong>)
  </td>
  <td> 
      - sets the mock function's return value only once (expires when called once)
  </td>
</tr>
</table>
  <br>
<table class="table">
<caption>
    Spying
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method  </th>
        <th> Description </th>
    </tr>
<tr class="0">
  <td> 
        jest.spyOn(<strong>obj</strong>, <strong>method:str</strong>, <small class="openable">get|set<div>
          <p> Supported from Jest v22.1.0 </p>
          <p> - spies only when the property is get or set </p>
        </div></small>)
  </td>
  <td> 
      - spies on the specified object's method by returning a <strong>mockFn</strong> <br>
      - the returned <strong>mockFn</strong> holds the spied data <br>
      - we can also mock the object method by registering a mock implementation (ex: <mark><strong>mockFn</strong>.mockImplementation(<strong>fn</strong>)</mark>)
  </td>
</tr>
<tr class="0">
  <td> 
        <strong>mockFn</strong>.mockRestore()
  </td>
  <td> 
      - for this <strong>mockFn</strong> returned by <mark>jest.spyOn()</mark> <br>
      - resets (empties) all data in <mark>mock.calls</mark> and <mark>mock.results</mark>, removes any mock implementation and <u>stops spying</u> 
  </td>
</tr>
<tr class="0">
  <td> 
        jest.restoreAllMocks()
  </td>
  <td> 
      - for all <strong>mockFn</strong> returned by <mark>jest.spyOn()</mark> <u>in this scope</u> <br>
      - stops spying 
  </td>
</tr>
    
    
    
    
    
    
    
    
    
<tr class="0">
  <td> 
        
  </td>
  <td> 
      - 
  </td>
</tr>
</table>



    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - mocking is faking a specific behaviour (like replacing a 'mocked' function with the original) </p>
  <p> - spying is 'spying' on some specific behaviour (like a function has ben called or not) </p>
  <p> - stabbing is replacing an original data with a fake one </p>
<hr>
<!----------------------------------------------------------------------------------->
<h2 style='color:darkblue;'><u> Mock Functions <mark>jest.fn()</mark> / <mark>jest.isMockFunction()</mark> / <mark>mockImplementaion()</mark> / <mark>mockImplementaionOnce()</mark> / <mark>mockReturnValue()</mark> / <mark>mockReturnValueOnce()</mark> / <mark>mockReturnThis()</mark> / <mark>mockResolvedValue()</mark> / <mark>mockResolvedValueOnce()</mark> / <mark>mockRejectValue()</mark> / <mark>mockRejectValueOnce()</mark> / <mark>mockName()</mark> / <mark>getMockName()</mark> / <mark>mock.calls</mark> / <mark>mock.results</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockClear()</mark> / <mark>jest.resetAllMocks()</mark> / <mark>.mockReset()</mark> </u></h2>
<details class="example"> 
<summary> DEMO </summary>
  <pre>
  test('some-test', function(){
// jest.fn() / jest.isMockFunction() --------------------------------------------------
    const mockFn = jest.fn()                                                           // creates a mock function (without implementation -> returns undefined) 
    const mockFn2 = jest.fn(function(val, idx, arr){                                   // creates a mock function with a mock implementation (function which runs when the mock is called)   
      return [idx, val]
    })
    
    mockFn();                                                                          // -> undefined 
    
    const someArray = ['un', 'deux', 'trois'];
    const newArray = someArray.map(mockFn2);                                           // the mock function is replaced and executed with te original (original callback is never called)
    
    newArray;                                                                          // -> [[0, 'un'], [1, 'deux'], [2, 'trois']] 
    
    
    jest.isMockFunction(mockFn)                                                        // -> true
    jest.isMockFunction(function(){})                                                  // -> false
    
// mockImplementation() / mockImplementaionOnce() -------------------------------------
    const mockFn = jest.fn(() => 21)
    mockFn.mockImplementation(() => 22)                                                // overrides the previous mock implementation 
    
    mockFn();                                                                          // -> 22
    
    mockFn.mockImplementationOnce(() => 'one');                                        // overrides the previous mock implementation for one call only 
    mockFn.mockImplementationOnce(() => 'two');
        
    mockFn();                                                                          // -> 'one'
    mockFn();                                                                          // -> 'two'
    mockFn();                                                                          // -> 22 
    mockFn();                                                                          // -> 22 
    
// mockReturnValue() / mockReturnValueOnce() / mockReturnthis() -----------------------
    const mockFn = jest.fn(() => 21);
    mockFn.mockReturnValue(22);                                                        // sets the return value of the mock function (regardless of the mock implementation)    
    
    mockFn();                                                                          // -> 22 
    
    mockFn.mockReturnValueOnce('one');                                                 // sets the return value for one call only  
    mockFn.mockReturnValueOnce('two');
    
    mockFn();                                                                          // -> 'one'
    mockFn();                                                                          // -> 'two'
    mockFn();                                                                          // -> 22
    mockFn();                                                                          // -> 22
    
    const mockFn2 = jest.fn().mockReturnThis()
    const myObj = {mockFn2}
    
    myObj.mockFn2();                                                                   // -> returns the myObj (the this value of the mock function)   
    
// getMockName() / mockName() ---------------------------------------------------------
    const mockFn = jest.fn();                                                          // jest function mock names are printed on the console 
    
    mockFn.getMockName();                                                              // -> 'jest.fn()'
    
    mockFn.mockName('awesome mock!');                                                  // sets the mock function's name 
    mockFn.getMockName();                                                              // -> 'awesome mock!'
  })
  </pre>
  <p> - <mark>mockResolvedValue()</mark> / <mark>mockResolvedValueOnce()</mark> / <mark>mockRejectedValue()</mark> / <mark>mockRejectedValueOnce()</mark> </p>
  <pre>
  test('some test', function(){
// mockResolvedValue() / mockResolvedValueOnce() --------------------------------------
    const mockFnRes = jest.fn(() => Promise.resolve());
    
    mockFnRes.mockResolvedValue(21);                                                   // sets the resolved value for a mock function that returns a resolved promise 
    mockFnRes.mockResolvedValueOnce('one');                                            // sets the resolved value for one promise consumption  
    mockFnRes.mockResolvedValueOnce('two');
    
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 'one'
      .catch((rej) => console.log(rej))
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 'two'
      .catch((rej) => console.log(rej))
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 21
      .catch((rej) => console.log(rej))
    mockFnRes()
      .then((res) => console.log(res))                                                 // -> 21
      .catch((rej) => console.log(rej))
  
// mockRejectedValue() / mockRejectedValueOnce() -------------------------------------
    const mockFnRej = jest.fn(() => Promise.reject());
    
    mockFnRej.mockRejectedValue(22);                                                   // sets the rejected value for a mock function that returns a rejected promise
    mockFnRej.mockRejectedValueOnce('un');                                             // sets the rejected value for one promise consumption  
    mockFnRej.mockRejectedValueOnce('deux');
  
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 'un'
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 'deux'
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 22
    mockFnRej()
      .then((res) => console.log(res))
      .catch((rej) => console.log(rej))                                                // -> 22
  })  
  </pre>
  <p> - <mark>mock.calls</mark> / <mark>mock.results</mark> / <mark>.mockClear()</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockReset()</mark> / <mark>jest.resetAllMocks()</mark> </p>
  <pre>
  test('some-test', function(){
// mock.calls / mock.results ----------------------------------------------------------
    const mockFn = jest.fn( (a, b) => a + b );
    
    mockFn(1, 2);
    mockFn(5, 5);
    
    mockFn.mock.calls;                                                                 // -> [[1, 2], [5, 5]]                                        // returns the mock call arguments for each call 
    mockFn.mock.results;                                                               // -> [{type:'return', value:3}, {type:'return', value:10}]   // returns the results for each call 
  
// .mockClear() / jest.crearAllMocks() ------------------------------------------------
    const mockFn1 = jest.fn((a, b) => a + b);
    const mockFn2 = jest.fn((a, b) => a + b);
    const mockFn3 = jest.fn((a, b) => a + b);
    
    mockFn1(1, 2)
    mockFn2(5, 5)
    mockFn3(7, 4)
    
    mockFn1.mock.calls;                                                                // -> [[1, 2]]                    
    mockFn2.mock.results;                                                              // -> [{type:'return', value:10}] 
    mockFn3.mock.results;                                                              // -> [{type:'return', value:11}] 
    
    mockFn1.mockClear();                                                               // clears the 'mock.calls' and mock.results' for this mock function only 
    
    mockFn1.mock.calls;                                                                // -> [] 
    mockFn2.mock.results;                                                              // -> [{type:'return', value:10}] 
    mockFn3.mock.results;                                                              // -> [{type:'return', value:11}] 
    
    jest.clearAllMocks();                                                              // clears the 'mock.calls' and mock.results' for all mock functions of this scope  
    
    mockFn1.mock.calls;                                                                // -> [] 
    mockFn2.mock.results;                                                              // -> [] 
    mockFn3.mock.results;                                                              // -> []   
    
    mockFn1(1, 2);                                                                     // -> 3              // does not remove any mock implementation 
    
// .mockReset() / jest.resetAllMocks() ------------------------------------------------
    const mockFn4 = jest.fn((a, b) => a + b);
    const mockFn5 = jest.fn((a, b) => a + b);
    
    mockFn4(1, 2)
    mockFn5(5, 5)
    
    mockFn4.mock.calls;                                                                // -> [[1, 2]]                    
    mockFn5.mock.results;                                                              // -> [{type:'return', value:10}] 
    
    mockFn4.mockReset;                                                                              // clears the 'mock.calls' and mock.results' and also resets all mock implementations for this mock function only   
    
    mockFn4.mock.calls;                                                                // -> []
    mockFn5.mock.results;                                                              // -> [{type:'return', value:10}]
    mockFn4(1, 2);                                                                     // -> undefined        // because mock implementations are cleared as well 
    mockFn5(5, 5);                                                                     // -> 10 
    
    jest.resetAllMocks;                                                                             // clears the 'mock.calls' and mock.results' and also resets all mock implementations for all mock functions of this scope   
    
    mockFn4.mock.calls;                                                                // -> []
    mockFn5.mock.results;                                                              // -> []
    mockFn4(1, 2);                                                                     // -> undefined        // because mock implementations are cleared as well 
    mockFn5(5, 5);                                                                     // -> undefined  
  })
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style="color:darkblue"><u> <mark>jest.fn()</mark> / <mark>jest.isMockFunction()</mark> TEST </u></h4>
  <pre>
  test('some-test', function(){
    const mockFn = jest.fn()                                                           // creates a mock function that returns undefined 
    const mockFn2 = jest.fn(function(val, idx, arr){                                   // creates a mock function with a specific behaviour 
      return [idx, val]
    })
    
    console.log( jest.isMockFunction(mockFn) );                                        // -> true      // mock function
    console.log( jest.isMockFunction(() => {}) );                                      // -> false     // not a mock function 
    
// basic usage of mock functions ------------------------------------------------------
    const someArray = ['un', 'deux', 'trois'];
    
    const newArray = someArray.map(mockFn2);                                           // the mock function is replaced and executed with te original (original callback is never called)
    
    console.log( newArray );                                                           // -> [[0, 'un'], [1, 'deux'], [2, 'trois']] 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockImplementation()</mark> / <mark>.mockImplementationOnce()</mark> TEST </u></h4>
  <pre>
// 'module_1.js' (file) ---------------------------------------------------------------
  module.exports = class Animal {
    constructor(race, wild){
      this.race = race;
      this.wild = wild;
    }
    
    getAnimal(){
      return {
        race: this.race,
        wild: this.wild
      }
    }
  }

// 'jestTest.test.js' (file) ----------------------------------------------------------
  const AnimalClass = jest.createMockFromModule('./module_1')                          // imported mocked class 
  
  test('some-test', function(){
    const mockFn = jest.fn(() => 21);
    mockFn.mockImplementation(() => 22)                                                // overrides the mock function implementation 
    
    console.log( mockFn() );                                                           // -> 22
    
    console.log( jest.isMockFunction(AnimalClass) );                                   // -> true    // a mocked classes are turned into mockFunctions 
    AnimalClass.mockImplementation(function(){                                         // we can use it on a mocked class 
      return {
        getAnimal: function(){
          return 'some animal'
        }
      }
    })
    
    const animal = new AnimalClass();
    console.log( animal.getAnimal() );                                                 // -> 'some animal'
    
  // mockImplementationOnce() ---------------------------------------------------------
    const mockFn2 = jest.fn(() => 'default');
    mockFn2
      .mockImplementationOnce(() => 'one')                                             // implements the specified mock function only once 
      .mockImplementationOnce(() => 'two')                                             // returns the mock function so we can chain it 
    
    console.log( mockFn2() );                                                          // -> 'one'
    console.log( mockFn2() );                                                          // -> 'two'
    console.log( mockFn2() );                                                          // -> 'default'
    console.log( mockFn2() );                                                          // -> 'default'
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockReturnValue()</mark> / <mark>.mockReturnValueOnce()</mark> / <mark>mockReturnThis()</mark> TEST </u></h4>
  <pre>
  test('some-test', function(){
    const mockFn = jest.fn();
    mockFn.mockReturnValue('default');                                                 // sets the return value of the mock function 
    
    console.log( mockFn() );                                                           // -> 'default'
    console.log( mockFn() );                                                           // -> 'default'
    
    mockFn.mockReturnValueOnce('one');                                                 // sets the return value of the mock function for one call only 
    mockFn.mockReturnValueOnce('two'); 
    
    console.log( mockFn() );                                                           // -> 'one'
    console.log( mockFn() );                                                           // -> 'two'
    console.log( mockFn() );                                                           // -> 'default'
    console.log( mockFn() );                                                           // -> 'default'
    
// .mockReturnThis() ------------------------------------------------------------------
    console.log( mockFn.mockReturnThis() )                                             // -> MockConstructor     // returns the this value of the mock function (which is the Mock constructor in this case)
    
    const myObj = {p1:21, someFn: jest.fn()};
    console.log( myObj.someFn.mockReturnThis() )                                       // -> MockConstructor     // apparently the this value of a mock function is always the Mock constructor
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockResolvedValue()</mark> / <mark>.mockResolvedValueOnce()</mark> / <mark>.mockRejectedValue()</mark> / <mark>.mockRejectedValueOnce()</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
// mockResolvedValue() / mockResolvedValueOnce() --------------------------------------
    const mockFnRes = jest.fn(() => Promise.resolve());                                // mock function that return a rejected promise 
    mockFnRes.mockResolvedValue('resolve default');                                    // sets the resolved value of the mock function that returns a resolved promise 
    
    console.log( await mockFnRes() );                                                  // -> 'resolve default'
    
    mockFnRes.mockResolvedValueOnce('resolved one');                                   // sets the resolved value for one call only 
    mockFnRes.mockResolvedValueOnce('resolved two');
    
    console.log( await mockFnRes() );                                                  // -> 'resolve one'
    console.log( await mockFnRes() );                                                  // -> 'resolve two'
    console.log( await mockFnRes() );                                                  // -> 'resolve default'
    console.log( await mockFnRes() );                                                  // -> 'resolve default'
  
// mockRejectedValue() / mockRejectedValueOnce() --------------------------------------
    const mockFnRej = jest.fn(() => Promise.reject());                                 // mock function that return a rejected promise 
    mockFnRej.mockRejectedValue('rejected default');                                   // sets the rejected value of the mock function that returns a rejected promise 
    
    await expect(mockFnRej()).rejects.toBe('rejected default');                        // passes (rejected value is matching)
    
    mockFnRej.mockRejectedValueOnce('rejected one');                                   // sets the rejected value for one call only 
    mockFnRej.mockRejectedValueOnce('rejected two');
    
    await expect(mockFnRej()).rejects.toBe('rejected one');                            // passes (rejected value is matching)
    await expect(mockFnRej()).rejects.toBe('rejected two');                            // passes (rejected value is matching)
    await expect(mockFnRej()).rejects.toBe('rejected default');                        // passes (rejected value is matching)
    await expect(mockFnRej()).rejects.toBe('rejected default');                        // passes (rejected value is matching)
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockName()</mark> / <mark>.getMockName()</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
    const mockFn = jest.fn();
    
    console.log( mockFn.getMockName() );                                               // -> 'jest.fn()'    // default jest function name 
    
    mockFn.mockName('my mock function');                                               // sets the mock function's name 
    console.log( mockFn.getMockName() );                                               // -> 'my mock function'
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>mock.calls</mark> / <mark>mock.results</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
    const mockFn = jest.fn(function(a, b){
      return a + b;
    });
    
    mockFn(1, 2)
    mockFn(5, 5)
    
    console.log( mockFn.mock.calls );                                                  // -> [[1, 2], [5, 5]]                                        // returns the mock call arguments for each call 
    console.log( mockFn.mock.results );                                                // -> [{type:'return', value:3}, {type:'return', value:10}]   // returns the results for each call 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockClear()</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockReset()</mark> / <mark>jest.resetAllMocks()</mark> TEST </u></h4>
  <pre>
  test('some-test', async function(){
// .mockClear() / jest.crearAllMocks() ------------------------------------------------
    const mockFn1 = jest.fn((a, b) => a + b);
    const mockFn2 = jest.fn((a, b) => a + b);
    const mockFn3 = jest.fn((a, b) => a + b);
    
    mockFn1(1, 2)
    mockFn2(5, 5)
    mockFn3(7, 4)
    
    console.log( mockFn1.mock.calls );                                                 // -> [[1, 2]]                    
    console.log( mockFn2.mock.results );                                               // -> [{type:'return', value:10}] 
    console.log( mockFn3.mock.results );                                               // -> [{type:'return', value:11}] 
    
    mockFn1.mockClear();                                                               // clears the 'mock.calls' and mock.results' for this mock function only 
    
    console.log( mockFn1.mock.calls );                                                 // -> [] 
    console.log( mockFn2.mock.results );                                               // -> [{type:'return', value:10}] 
    console.log( mockFn3.mock.results );                                               // -> [{type:'return', value:11}] 
    
    jest.clearAllMocks();                                                              // clears the 'mock.calls' and mock.results' for all mock functions 
    
    console.log( mockFn1.mock.calls );                                                 // -> [] 
    console.log( mockFn2.mock.results );                                               // -> [] 
    console.log( mockFn3.mock.results );                                               // -> []   
    
    console.log( mockFn1(1, 2) )                                                       // -> 3              // does not remove any mock implementation 
    
// .mockReset() / jest.resetAllMocks() ------------------------------------------------
    const mockFn4 = jest.fn((a, b) => a + b);
    const mockFn5 = jest.fn((a, b) => a + b);
    
    mockFn4(1, 2)
    mockFn5(5, 5)
    
    console.log( mockFn4.mock.calls );                                                 // -> [[1, 2]]                    
    console.log( mockFn5.mock.results );                                               // -> [{type:'return', value:10}] 
    
    mockFn4.mockReset();                                                               // clears the 'mock.calls' and mock.results' and also resets all mock implementations for this mock  function only   
    
    console.log( mockFn4.mock.calls );                                                 // -> []
    console.log( mockFn5.mock.results );                                               // -> [{type:'return', value:10}]
    console.log( mockFn4(1, 2) );                                                      // -> undefined        // because mock implementations are cleared as well 
    console.log( mockFn5(5, 5) );                                                      // -> 10 
    
    jest.resetAllMocks();                                                              // clears the 'mock.calls' and mock.results' and also resets all mock implementations for all mock   functions    
    
    console.log( mockFn4.mock.calls );                                                 // -> []
    console.log( mockFn5.mock.results );                                               // -> []
    console.log( mockFn4(1, 2) );                                                      // -> undefined        // because mock implementations are cleared as well 
    console.log( mockFn5(5, 5) );                                                      // -> undefined  
  })
  </pre>
</details>
<hr>
<!----------------------------------------------------------------------------------->
<h2 style="color:darkblue;"><u> Spying <mark>jest.spyOn()</mark> / <mark>mockRestore()</mark> / <mark>jest.restoreAllMocks()</mark> / <mark>toHaveBeenCalled()</mark> / <mark>toHaveBeenCalledTimes()</mark> / <mark>toHaveBeenCalledWith()</mark> / <mark>toHaveBeenLastCalledWith()</mark> / <mark>toHaveBeenNthCalledWith()</mark> / <mark>toHaveReturned()</mark> / <mark>toHaveReturnedTime()</mark> / <mark>toHaveReturnedWith()</mark> / <mark>toHaveLastReturnedWith()</mark> / <mark>toHaveNthReturnedWith()</mark> </u></h2>
<details class="example" open> 
<summary> DEMO </summary>
  <pre>
  
  
  
  
  </pre>
</details>


<details class="example" open> 
<summary> Example </summary>
<h4 style="color:darkblue"><u> <mark>jest.spyOn()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const myObj = { add(a, b){ return a + b} }
    
    const spy = jest.spyOn(myObj, 'add');                                              // spying on the specified object method   
    
    myObj.add(1, 2);                                                                   // -> 3
    
    expect(spy).toHaveBeenCalled();                                                    // the spy is used to spy on the spied method 
    
// apply mock implementation ----------------------------------------------------------
    spy.mockImplementation(() => 'new mock implementation!');                          // mock implementation applied on the object's method 
    console.log( myObj.add(1, 2) );                                                    // -> 'new mock implementation!' 
    
    myObj.add = jest.fn(() => 'another mock implementation!')
    console.log( myObj.add(1, 2) );                                                    // -> 'another mock implementation!' 
    
// using 'get' 'set' options ----------------------------------------------------------
    const myObj2 = {
      animal_: 'default animal',
      get animal() { return this.animal_ },
      set animal(val) { this.animal_ = val }
    }
    
    const spy_get = jest.spyOn(myObj2, 'animal', 'get');                               // spies only when get the property 
    const spy_set = jest.spyOn(myObj2, 'animal', 'set');                               // spies only when set the property 
    
    myObj2.animal = 'cat';
    
    console.log( spy_set.mock.calls )                                                  // -> [['cat]]    // only the set spy is triggered 
    console.log( spy_get.mock.calls )                                                  // -> []          // empty because the spy_get does not spy when the property gets 
    
    jest.clearAllMocks();                                                              // clears all mocks in this scope 
    
    myObj2.animal; 
    
    console.log( spy_set.mock.calls )                                                  // -> []
    console.log( spy_get.mock.calls )                                                  // -> [[]]        // only the get spy is triggered 
  })

  
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>mockRestore()</mark> / <mark>jest.restoreAllMocks()</mark> TEST </u></h4>
  <pre>
  test('some test', function(){
    const myObj = { 
      add(a, b){ return a + b},
      multiply(a, b){ return a * b}
    }
    
    const spy1 = jest.spyOn(myObj, 'add'); 
    const spy2 = jest.spyOn(myObj, 'multiply'); 
    
    myObj.add(3, 2);
    myObj.multiply(3, 2);
    
    console.log( spy1.mock.calls );                                                    // -> [[3, 2]]
    console.log( spy2.mock.calls );                                                    // -> [[3, 2]]
    
    spy1.mockRestore();                                                                // clears all data from 'mock.calls' and 'mock.results' removes the mock implementation and stops the spying  
    
    console.log( spy1.mock.calls );                                                    // -> []
    console.log( spy2.mock.calls );                                                    // -> [[3, 2]]
    
    jest.restoreAllMocks();                                                            // stops all spies in this scope 
    
    myObj.add(3, 2);
    myObj.multiply(3, 2);
    
    console.log( spy1.mock.calls );                                                    // -> []            // no further spying 
    console.log( spy2.mock.calls );                                                    // -> [[3, 2]]
  })
  </pre>
  
  
  
  
  
  
</details>








<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
  - jest configurations 
    - we can write jest configs in the nearest package.json file in an object under "jest" top level key
    - jest.config.js|ts file (I suppose this file is looked up in the directory where jest runs)
    - we can use the --config [configFilePath] flag to setup where the jest config file is 
    
    
  https://jestjs.io/docs/configuration#options
    - link to jest config options 
    
  
  
  the 'jest' object is automatically in scope in all jest files 
  
  
  
  jest.spyOn(obj, method, accessType)
      - returns a mockFn which acts as a spy for the specified obj[method] 
      - this guy is used to spy on the obj[method] (ex: expect(mockFn).toHaveBeenCalled())
      - accessType is supported from jest v.22.1.0  (get|set) we can specify to which property to spy on 
  jest.restoreAllMocks()
      - equivalent to .mockRestore()
  mockFn.mockRestore()
      - does what 'mockReset()' does and resets the function before the mocked state
    
- expect (spy) matchers 
  .toHaveBeenCalled() 
      - the mock function have been called 
  .toHaveBeenCalledTimes(nr)
      - the mock function have been called nr times 
  
  
  .toHaveBeenCalledWith(arg, ...)
      - the mock function have been called with these argumenst 
  .toHaveBeenLastCalledWith(arg, ...)
      - the mock function have been called with these argument when it was called for the last time 
  .toHaveBeenNthCalledWith(nthCall, arg, ...)
      - the mock function habe been called with these argument when it was called nth time 
  
  
  .toHaveReturned()
      - the mock function returned (not thrown)
      - test if nothing is returned what happesn then 
  .toHaveReturnedTime(nr)
      - the mock function returned nth of times 
  .toHaveReturnedWith(val)
      - the mock function retuned val
  .toHaveLastReturnedWith(val)
      - the mock function lastly returned val
  .toHaveNthReturnedWith(nthCall, val)
      - the mock function returned val at the nth call 
    
    
    
    
- Mocking modules 
  
    - mocked modules :
    - exported functions are mocked as mockFn (return undefined)
    - exported classes (keep their original interface? -> well not so) but their member functions and properties are mocked 
      - a mocked class is essentially becomes a mock function 
    - exported objects are deeply cloned and keep their original keys but key values are mocked according to mockink values (ex a function is mocked, a primitive is not mocked)
    - exported arrays will ba a new empty arrasy 
    - exported primitives will be cloned as the original 
    
    
    - manual mocking 

    
    jest.disableAutomock()
      - disables automocking (set in configurations)
      - returns the Jest (object for chaining)
    jest.enableAutomock()
      - enables automocking 
      - returns the Jest (object for chaining)
    jest.createMockFromModule(moduleName:str)
      - creates a mock from the given module 
      - returns the mocked module 
    jest.mock(modulePath, factorymock, {virtual: true})
      - mocks an imported module 
      - so once the module is mocked we can use mockFn methods on it
      - returns the Jest object (for chaining)
    jest.unmock(module)
      - prevents the 'module' from mocking 
      - returns the Jest object (for chaining)
    jest.returnActual(module)
      - returns the actual (original) module 
      - does this guy request explicitly the module ??? TEST 
    jest.requireMock(module)
      - mocks the 'module' and returns the mock module object 
    jest.resetModules()
      - resets the require cache (node keeps already required modules, this guy resets that cache to the module will be required explicitly again)
      - returns the jest object for chaining 
    jest.isolateModules(fn)
      - explicitly require modules and isolate them callback 
      - returns the jest object 
    
    
    
- Fake Timers 
    - timers cannot be used in tests (unless wrapped in a Promise), so the solution is to use fake timers 
    
    jest.useFakeTimers()
      - jest will use fake timers (timer are ignored setTimeout, setInterval, setImmediate, nextTick and Date)
      - mocks out timers 
      - affect all timers in the file, regardless of describe scoping 
    jest.useRealTimers()
      - jest will use original timers (usually we execute this after testing so 3rd party libraries are not confused)
    jest.runAllTicks()
      - immediately executes all mocked process.nextTick callbacks 
      - synchronously executes timers 
    jest.runAllTimers()
      - immediately executes all mocked process.nextTick and all timers 
      - basically synchronously executes timers 
    jest.runAllImmediates()
      - immediately executes all setImmediate
    jest.advanceTimersByTime(ms:nr)
      - advances the timer 
    jest.runOnlyPendingTimers()
      - only executes the currently pending timers (ex for setInterval is pending only the first interval thant the second is not pending )
    jest.advanceTimersToNextTimer(step)
      - advances the time till the next timer is called then stops 
    jest.clearTimers()
      - all pending timers are cleared and never executed in the future 
    jest.getTimerCount()
      - returns the number of pending timers 
    jest.setSystemTime(ms)
      - sets the system time when using fake timers 
    jest.getRealSystemTime()
      - returns the real time when we using fake timers 
      
      
    jest.setTimeout(ms)
      - number of millisecons jest waits for async tasks to finish (valid for this file only)
    jest.retryTimes()
      - number of tryes jest retryes failed tests 
    
    
    
    
    
    
    
    
?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
  - when mocking modules only import functions are mocked? (other properties are not)
  
  
  
  
-->


<!--
    mock -> simulating (replacing) a specific behaviour   
  stub -> faking some data 
  spy -> spying on some behaviour like mocked function 
  
  
  
  
- Mock Functions 
  jest.fn([fn])  
      - returns an unused mock function (optionally can accept a mockImplementation function)
  jest.isMockFunction(fn)
      - checks if the passed function is a mock function or not 
    
  mockFn.mockImplementation(fn)
      - overrides the mock function 
  mockFn.mockImplementaionOnce(fn)
      - overrides the mock function once 
    
  mockFn.mockReturnValue()
  mockFn.mockReturnValueOnce()
      - specifies the mock function return value (for one time)
  mockFn.mockReturnThis()
      - returns the mock's this value 
      
  mockFn.mockResolvedValue(val)
      - sets the resolved mock value for async mock functions 
  mockFn.mockResolvedValueOnce(val)
      - sets the resolved mock value for async mock functions once 
  mockFn.mockRejectValue(val)
      - sets the reject mock value for async mock functions 
  mockFn.mockRejectValueOnce(val)
      - sets the reject mock value for async mock functions 
    
  mockFn.mockName(name:str)
      - names the mock function 
  mockFn.getMockName()
      - returns the mock function's name 
    
  mockFn.mock.calls
      - an Array containing all calls with call arguments 
  mockFn.mock.results
      - an Array containing all call resutls 
    
  jest.clearAllMocks()
      - equivalent to .mockClear()
  mockFn.mockClear()
      - resets all informations in 'mock.calls and mock.instances' -> basically replaces mockFn.mock
  jest.resetAllMocks()
      - equivalent to .mockReset()
  mockFn.mockReset()
      - does what 'mockClear()' but also removes mock returns and implementations 
      
      


-->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2><u> Title 1 </u></h2>
<h2 style="color:darkblue;"> Title 1.1 </h2>
<h3 style="color:darkblue;"> Title 1.1.1 </h3>
<h4 style="color:darkblue;"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>keywords_are_highlighted()</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
