<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Demo </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Mokking, Spying & Stabbing (ver 4.0.0) </h1>
    <p> Updated ( 2021-08-20 )</p>
    <p class="sitenav"> 
      <a href="../../index.html">MySite> </a> 
      <a href="../index.html">Jest> </a> Mokking, Spying & Stabbing
    </p>
<table class="table">
<caption>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method  </th>
        <th> Description </th>
    </tr>
<tr class="0">
  <td> 
        jest.fn(<i class="openable">fn<div>
          <p> - 'mock implementation', we can pass a function here which is ececuted when the mock function is called </p>
        </div></i>)
  </td>
  <td> 
      - creates and returns a <strong>mockFn</strong> 
  </td>
</tr>
<tr class="0">
  <td> 
        jest.isMockFunction(<strong>fn</strong>)
  </td>
  <td> 
        - returns <mark>true</mark> if the passed <strong>fn</strong> is a mock function, <mark>false</mark> otherwise
  </td>
</tr>







<tr class="0">
  <td> 
        
  </td>
  <td> 
      - 
  </td>
</tr>
</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - mocking is faking a specific behaviour (like replacing a 'mocked' function with the original) </p>
  <p> - spying is 'spying' on some specific behaviour (like a function has ben called or not) </p>
  <p> - stabbing is replacing an original data with a fake one </p>
<hr>
<!----------------------------------------------------------------------------------->
<h2 style='color:darkblue;'><u> Mocking <mark>jest.fn()</mark> / <mark>jest.isMockFunction()</mark> / <mark>mockImplementaion()</mark> / <mark>mockImplementaionOnce()</mark> / <mark>mockReturnValue()</mark> / <mark>mockReturnValueOnce()</mark> / <mark>mockReturnThis()</mark> / <mark>mockResolvedValue()</mark> / <mark>mockResolvedValueOnce()</mark> / <mark>mockRejectValue()</mark> / <mark>mockRejectValueOnce()</mark> / <mark>mockName()</mark> / <mark>getMockName()</mark> / <mark> / <mark>mock</mark> / <mark>mock.instances</mark> / <mark>mock.calls</mark> / <mark>mock.results</mark> / <mark>jest.clearAllMocks()</mark> / <mark>.mockClear()</mark> / <mark>jest.resetAllMocks()</mark> / <mark>.mockReset()</mark> / <mark>jest.restoreAllMocks()</mark> / <mark>.mockRestore()</mark>  </u></h2>




<details class="example" open> 
<summary> DEMO </summary>
  
  
  
</details>
  
<details class="example" open> 
<summary> Example : </summary>
<h4 style="color:darkblue"><u> <mark>jest.fn()</mark> / <mark>jest.isMockFunction()</mark> TEST </u></h4>
  <pre>
  test('some-test', function(){
    const mockFn = jest.fn()                                                           // creates a mock function that returns undefined 
    const mockFn2 = jest.fn(function(val, idx, arr){                                   // creates a mock function with a specific behaviour 
      return [idx, val]
    })
    
    console.log( jest.isMockFunction(mockFn) );                                        // -> true      // mock function
    console.log( jest.isMockFunction(() => {}) );                                      // -> false     // not a mock function 
    
// basic usage of mock functions ------------------------------------------------------
    const someArray = ['un', 'deux', 'trois'];
    
    const newArray = someArray.map(mockFn2);                                           // the mock function is replaced and executed with te original (original callback is never called)
    
    console.log( newArray );                                                           // -> [[0, 'un'], [1, 'deux'], [2, 'trois']] 
  })
  </pre>
<hr>
<!----------------------------------------------------------------------------------->
<h4 style="color:darkblue"><u> <mark>.mockImplementation()</mark> / <mark>.mockImplementationOnce()</mark> TEST </u></h4>
  <pre>
  
  
  
  
  </pre>
  
  
  
  
</details>



<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
  - jest configurations 
    - we can write jest configs in the nearest package.json file in an object under "jest" top level key
    - jest.config.js|ts file (I suppose this file is looked up in the directory where jest runs)
    - we can use the --config [configFilePath] flag to setup where the jest config file is 
    
    
  https://jestjs.io/docs/configuration#options
    - link to jest config options 
    
  
  mock -> simulating (replacing) a specific behaviour   
  stub -> faking some data 
  spy -> spying on some behaviour like mocked function 
  
  
  the 'jest' object is automatically in scope in all jest files 
  
  
  
- Mock Functions 
  jest.fn([fn])  
      - returns an unused mock function (optionally can accept a mockImplementation function)
  jest.isMockFunction(fn)
      - checks if the passed function is a mock function or not 
    
  mockFn.mockImplementation(fn)
      - overrides the mock function 
  mockFn.mockImplementaionOnce(fn)
      - overrides the mock function once 
    
  mockFn.mockReturnValue()
  mockFn.mockReturnValueOnce()
      - specifies the mock function return value (for one time)
  mockFn.mockReturnThis()
      - returns the mock's this value 
      
  mockFn.mockResolvedValue(val)
      - sets the resolved mock value for async mock functions 
  mockFn.mockResolvedValueOnce(val)
      - sets the resolved mock value for async mock functions once 
  mockFn.mockRejectValue(val)
      - sets the reject mock value for async mock functions 
  mockFn.mockRejectValueOnce(val)
      - sets the reject mock value for async mock functions 
    
  mockFn.mockName(name:str)
      - names the mock function 
  mockFn.getMockName()
      - returns the mock function's name 
    
  mockFn.mock
      - property holds the mock functions parameters (how many times it was called, returned value, etc...)
  mockFn.mock.instances 
      - holds the instances when the mock function was instantained 
  mockFn.mock.calls
      - an Array containing all calls with call arguments 
  mockFn.mock.results
      - an Array containing all call resutls 
    
  jest.clearAllMocks()
      - equivalent to .mockClear()
  mockFn.mockClear()
      - resets all informations in 'mock.calls and mock.instances' -> basically replaces mockFn.mock
  jest.resetAllMocks()
      - equivalent to .mockReset()
  mockFn.mockReset()
      - does what 'mockClear()' but also removes mock returns and implementations 
  jest.restoreAllMocks()
      - equivalent to .mockRestore()
  mockFn.mockResoter()
      - does what 'mockReset()' does and resets the function before the mocked state
      
      
      
  
  
  
  
  
  
  
  
  
- expect (spy) matchers 
  jest.spyOn(obj, method, accessType)
      - returns a mockFn which is called when obj[method] is called 
      - this guy is used to spy on the obj[method] (ex: expect(mockFn).toHaveBeenCalled())
      - accessType is supported from jest v.22.1.0  (get|set) we can specify to which property to spy on 
  .toHaveBeenCalled() 
      - the mock function have been called 
  .toHaveBeenCalledTimes(nr)
      - the mock function have been called nr times 
  .toHaveBeenCalledWith(arg, ...)
      - the mock function have been called with these argumenst 
  .toHaveBeenLastCalledWith(arg, ...)
      - the mock function have been called with these argument when it was called for the last time 
  .toHaveBeenNthCalledWith(nthCall, arg, ...)
      - the mock function habe been called with these argument when it was called nth time 
  .toHaveReturned()
      - the mock function returned (not thrown)
      - test if nothing is returned what happesn then 
  .toHaveReturnedTime(nr)
      - the mock function returned nth of times 
  .toHaveReturnedWith(val)
      - the mock function retuned val
  .toHaveLastReturnedWith(val)
      - the mock function lastly returned val
  .toHaveNthReturnedWith(nthCall, val)
      - the mock function returned val at the nth call 
    
    
    
    
- Mocking modules 
  
    - mocked modules :
    - exported functions are mocked as mockFn (return undefined)
    - exported classes keep their original interface but their member functions and properties are mocked 
    - exported objects are deeply cloned and keep their original keys but key values are mocked according to mockink values (ex a function is mocked, a primitive is not mocked)
    - exported arrays will ba a new empty arrasy 
    - exported primitives will be cloned as the original 
    
    
    - manual mocking 

    
    jest.disableAutomock()
      - disables automocking (set in configurations)
      - returns the Jest (object for chaining)
    jest.enableAutomock()
      - enables automocking 
      - returns the Jest (object for chaining)
    jest.createMockFromModule(moduleName:str)
      - creates a mock from the given module 
      - returns the mocked module 
    jest.mock(modulePath, factorymock, {virtual: true})
      - mocks an imported module 
      - so once the module is mocked we can use mockFn methods on it
      - returns the Jest object (for chaining)
    jest.unmock(module)
      - prevents the 'module' from mocking 
      - returns the Jest object (for chaining)
    jest.returnActual(module)
      - returns the actual (original) module 
      - does this guy request explicitly the module ??? TEST 
    jest.requireMock(module)
      - mocks the 'module' and returns the mock module object 
    jest.resetModules()
      - resets the require cache (node keeps already required modules, this guy resets that cache to the module will be required explicitly again)
      - returns the jest object for chaining 
    jest.isolateModules(fn)
      - explicitly require modules and isolate them callback 
      - returns the jest object 
    
    
    
- Fake Timers 
    - timers cannot be used in tests (unless wrapped in a Promise), so the solution is to use fake timers 
    
    jest.useFakeTimers()
      - jest will use fake timers (timer are ignored setTimeout, setInterval, setImmediate, nextTick and Date)
      - mocks out timers 
      - affect all timers in the file, regardless of describe scoping 
    jest.useRealTimers()
      - jest will use original timers (usually we execute this after testing so 3rd party libraries are not confused)
    jest.runAllTicks()
      - immediately executes all mocked process.nextTick callbacks 
      - synchronously executes timers 
    jest.runAllTimers()
      - immediately executes all mocked process.nextTick and all timers 
      - basically synchronously executes timers 
    jest.runAllImmediates()
      - immediately executes all setImmediate
    jest.advanceTimersByTime(ms:nr)
      - advances the timer 
    jest.runOnlyPendingTimers()
      - only executes the currently pending timers (ex for setInterval is pending only the first interval thant the second is not pending )
    jest.advanceTimersToNextTimer(step)
      - advances the time till the next timer is called then stops 
    jest.clearTimers()
      - all pending timers are cleared and never executed in the future 
    jest.getTimerCount()
      - returns the number of pending timers 
    jest.setSystemTime(ms)
      - sets the system time when using fake timers 
    jest.getRealSystemTime()
      - returns the real time when we using fake timers 
      
      
    jest.setTimeout(ms)
      - number of millisecons jest waits for async tasks to finish (valid for this file only)
    jest.retryTimes()
      - number of tryes jest retryes failed tests 
    
    
    
    
    
    
    
    
?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
  - when mocking modules only import functions are mocked? (other properties are not)
  
  
  
  
-->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2><u> Title 1 </u></h2>
<h2 style="color:darkblue;"> Title 1.1 </h2>
<h3 style="color:darkblue;"> Title 1.1.1 </h3>
<h4 style="color:darkblue;"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>keywords_are_highlighted()</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
