<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Jest </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> 
    <link rel="stylesheet" href="../Assets/stylesPages.css"> 
    <script src="../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Jest v27.0 (ver 4.0.0) </h1>
    <p> Updated ( 2021-07-18 )</p>
    <p class="sitenav"> <a href="../index.html">MySite></a> Jest </p>
<table class="table">
<caption>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Command </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td> 
        <em>npm install</em> jest</em> 
  </td>
  <td> 
        - installs jest 
  </td>
</tr>
<tr class="05.02">
  <td> 
         <strong>fileName</strong>.test.js
  </td>
  <td> 
        - jest file, jest will run these files in the current directory for testing 
  </td>
</tr>
<tr class="05.03">
  <td> 
        jest <small>[--coverage]</small> <i>jestFile</i>
  </td>
  <td> 
        - runs all jest files in the current direcoty or the specified file (the <mark>.test.js</mark> extension can be omitted ex: (<mark>jest someTest.test.js</mark> can be called as <mark>jest someTest</mark>)) <br>
        - (<small>--coverage</small>) also runs the coverage test (prints the result at the end of the test)
  </td>
</tr>
</table>
  <br>
<table class="table">
<caption>
    Scopes and Teardown
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
<tr class="05.0">
  <td colspan="2"> Scope Methods </td>
</tr>
<tr class="05.01">
  <td> 
        describe<small class="openable">[.only|skip<div>
          <p> <small>only</small> - only this describe scope will be executed in this test file </p>
          <p> <small>skip</small> - skips this describe scope </p>
        </div>]</small>(<strong>name:str</strong>, <strong>fn</strong>)
  </td>
  <td> 
        - creates a scope for test suites 
  </td>
</tr>
<tr class="10.01">
  <td> 
        describe<small class="openable">[.only|skip<div>
          <p> <small>only</small> - only this describe scope will be executed in this test file </p>
          <p> <small>skip</small> - skips this describe scope </p>
        </div>]</small>.each([<strong>item:any</strong>, <i>...</i>])(<strong class="openable">name:str<div>
          <p> <mark>%s</mark> - String </p>
          <p> <mark>%d</mark> - Number </p>
          <p> <mark>%i</mark> - Integer </p>
          <p> <mark>%f</mark> - Floating point value </p>
          <p> <mark>%j</mark> - JSON </p>
          <p> <mark>%o</mark> - Object </p>
          <p> <mark>%#</mark> - Index of the test case </p>
          <p> <mark>%%</mark> - single percent sign ('%'). This does not consume an argument </p>
        </div></strong>, <strong>fn</strong>)
  </td>
  <td> 
        - runs a describe scope for each <strong>item</strong> 
  </td>
</tr>
<tr class="20.01">
  <td colspan="2"> Teardown Methods </td>
</tr>
<tr class="20.02">
  <td> 
        afterAll(<strong>fn</strong>, <i class="openable">timeout:nr<div>
          <p> - default <mark>5000</mark> </p>
        </div></i>)
  </td>
  <td> 
        - runs the <strong>fn</strong> after all test suite cases in this scope  
  </td>
</tr>
<tr class="20.03">
  <td> 
        afterEach(<strong>fn</strong>, <i class="openable">timeout:nr<div>
          <p> - default <mark>5000</mark> </p>
        </div></i>)
  </td>
  <td> 
        - runs the <strong>fn</strong> after each test suite cases in this scope  
  </td>
</tr>
<tr class="25.01">
  <td> 
        beforeAll(<strong>fn</strong>, <i class="openable">timeout:nr<div>
          <p> - default <mark>5000</mark> </p>
        </div></i>)
  </td>
  <td> 
        - runs the <strong>fn</strong> before all test suite cases in this scope  
  </td>
</tr>
<tr class="25.02">
  <td> 
        beforeEach(<strong>fn</strong>, <i class="openable">timeout:nr<div>
          <p> - default <mark>5000</mark> </p>
        </div></i>)
  </td>
  <td> 
        - runs the <strong>fn</strong> before each test suite cases in this scope  
  </td>
</tr>
</table>
  <br>
<table class="table">
<caption>
    Test Cases   
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td> 
        test|it<small class="openable">[.only|skip<div>
          <p> <small>only</small> - runs only this test case in the file </p>
          <p> <small>skip</small> - skips this test case </p>
        </div>]</small>(<strong>name:str</strong>, <strong>fn</strong>, <i class="openable">timeout:nr<div>
          <p> - default <mark>5000</mark> </p>
        </div></i>)
  </td>
  <td> 
        - runs a test case (executes its <strong>fn</strong>) and prints the test <strong>name</strong> in the output  
  </td>
</tr>
<tr class="10.01">
  <td> 
        test|it<small class="openable">[.only|skip<div>
          <p> <small>only</small> - runs only this test case in the file </p>
          <p> <small>skip</small> - skips this test case </p>
        </div>]</small>.each([<strong>item:any</strong>, <i>...</i>])(<strong class="openable">name:str<div>
          <p> <mark>%s</mark> - String </p>
          <p> <mark>%d</mark> - Number </p>
          <p> <mark>%i</mark> - Integer </p>
          <p> <mark>%f</mark> - Floating point value </p>
          <p> <mark>%j</mark> - JSON </p>
          <p> <mark>%o</mark> - Object </p>
          <p> <mark>%#</mark> - Index of the test case </p>
          <p> <mark>%%</mark> - single percent sign ('%'). This does not consume an argument </p>
        </div></strong>, <strong>fn</strong>, <i class="openable">timeout:nr<div>
          <p> - default <mark>5000</mark> </p>
        </div></i>)
  </td>
  <td> 
        - runs a test case for each <strong>item</strong> (executes its <strong>fn</strong>) and prints the test <strong>name</strong> in the output  
  </td>
</tr>
<tr class="15.01">
  <td> 
        test|it.todo(<strong>name:str</strong>)
  </td>
  <td> 
        - writes a todo <strong>name</strong> at the end of the of the output (used to write notes in the test)
  </td>
</tr>
</table>
  <br>
<table class="table">
<caption>
    Expect and Matchers 
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
<tr class="05.01">
  <td colspan="2"> Expect </td>
</tr>
<tr class="05.02">
  <td> 
        expect(<strong>exp</strong>).<strong>matcherMethod</strong>
  </td>
  <td>
        - the <strong>exp</strong> return a result which is verified by the <strong>matcherMethod</strong> to check if the test passes of fails <br>
        - used inside a <mark>test</mark> function 
  </td>
</tr>
<tr class="15.01">
  <td> 
        expect.assertions(<strong>nr</strong>)
  </td>
  <td>
        - this test case must have <strong>nr</strong> of assertions in order for the test to pass <u>(supports asynchronous code)</u>
  </td>
</tr>
<tr class="10.05">
  <td> 
        expect.extend({<strong class="openable">fn(received)<div>
          <p> - the <strong>received</strong> is the value passed by the expect method preceding this matcher </p>
          <p> - the function returns an object <mark>{pass:<strong>bol</strong>, message:<strong>fn</strong>}</mark> based on a passed or failed test (<strong>fn</strong> generates and returns the message) </p>
        </div></strong><i>, ...</i>}) 
  </td>
  <td>
        - creates custom <strong>matcherMethod</strong>s that can be used anywhere in the jest scope (just like any other matcher methods)
  </td>
</tr>
<tr class="15.02">
  <td> 
        expect.hasAssertions()
  </td>
  <td>
        - this test case must have at least one assertion for the test to pass <u>(supports asynchronous code)</u>
  </td>
</tr>
<tr class="20.01">
  <td colspan="2"> Matchers Methods </td>
</tr>  
<tr class="20.02">
  <td> 
        not<strong>.matcherMethod</strong>
  </td>
  <td> 
        - negates the <strong>matcherMethod</strong> 
  </td>
</tr>
<tr class="25.01">
  <td> 
        toBe(<strong>val</strong>)
  </td>
  <td> 
        - the expected value should be equal <strong>val</strong> (uses the <mark>===</mark> operator) 
  </td>
</tr>
<tr class="35.05">
  <td> 
        toBeCloseTo(<strong>nr</strong>)
  </td>
  <td> 
        - the expected value should close to the <strong>nr</strong> (ex: <mark>0.1 + 0.2</mark> will be close to <mark>0.3</mark>)
  </td>
</tr>
<tr class="30.04">
  <td> 
        toBeDefined()
  </td>
  <td> 
        - the expected value should be <u>other than</u> <mark>undefined</mark> 
  </td>
</tr>
<tr class="30.06">
  <td> 
        toBeFalsy()
  </td>
  <td> 
        - the expected value should be evaluated <mark>false</mark>
  </td>
</tr>
<tr class="35.01">
  <td> 
        toBeGreaterThan(<strong>nr</strong>)
  </td>
  <td> 
        - the expected value should be greater than the <strong>nr</strong>   
  </td>
</tr>
<tr class="35.02">
  <td> 
        toBeGreaterThanOrEqual(<strong>nr</strong>)
  </td>
  <td> 
        - the expected value should be greater or equal than the <strong>nr</strong>   
  </td>
</tr>
<tr class="50.02">
  <td> 
        toBeInstanceOf(<strong>class</strong>)
  </td>
  <td> 
        - the expected data should be an instance of <strong>class</strong>
  </td>
</tr>
<tr class="35.03">
  <td> 
        toBeLessThan(<strong>nr</strong>)
  </td>
  <td> 
        - the expected value should be less than the <strong>nr</strong>   
  </td>
</tr>
<tr class="35.04">
  <td> 
        toBeLessThanOrEqual(<strong>nr</strong>)
  </td>
  <td> 
        - the expected value should be less or equal than the <strong>nr</strong>   
  </td>
</tr>
<tr class="30.02">
  <td> 
        toBeNaN()
  </td>
  <td> 
        - the expected value should be <mark>NaN</mark>
  </td>
</tr>
<tr class="30.01">
  <td> 
        toBeNull()
  </td>
  <td> 
        - the expected value should be <mark>null</mark> 
  </td>
</tr>
<tr class="30.05">
  <td> 
        toBeTruthy()
  </td>
  <td> 
        - the expected value should be evaluated <mark>true</mark>
  </td>
</tr>
<tr class="30.03">
  <td> 
        toBeUndefined()
  </td>
  <td> 
        - the expected value should be <mark>undefined</mark> 
  </td>
</tr>
<tr class="40.02">
  <td> 
        toContain(<strong>val</strong>)
  </td>
  <td> 
        - the expected data should be iterable that contains <strong>val</strong>   
  </td>
</tr>
<tr class="40.03">
  <td> 
        toContainEqual(<strong>data:any</strong>)
  </td>
  <td> 
        - the expected data should be an Array, one of the Array item should have the same data structure as <strong>data</strong> 
  </td>
</tr>
<tr class="25.02">
  <td> 
        toEqual(<strong>data</strong>)
  </td>
  <td> 
        - the expected data should be equal <strong>data</strong> <u>(recursively checks the expected data (used to compare objects))</u>
  </td>
</tr>
<tr class="45.01">
  <td> 
        toHaveLength(<strong>nr</strong>)
  </td>
  <td> 
        - the expected data should be iterable and should contain <strong>nr</strong> items 
  </td>
</tr>
<tr class="50.01">
  <td> 
        toHaveProperty(<strong class="openable">propPath:str<div>
          <p> - ex: an object nested property <mark>{p1:{n2:21}}</mark> can be reached as <mark>p1.n2</mark> </p> 
        </div></strong>)
  </td>
  <td> 
        - the expected data should be an object having <strong>propPath</strong> (nested properties can be reached)
  </td>
</tr>
<tr class="40.01">
  <td> 
        toMatch(<strong>str|regExp</strong>)
  </td>
  <td> 
        - the expected data should match <strong>str|regExp</strong>    
  </td>
</tr>
<tr class="40.02">
  <td> 
        toMatchObject(<strong>obj</strong>)
  </td>
  <td> 
        - the expected data should be an object, the <strong>obj</strong> should contain at least one key/value pair that is present in the expected object <br>
        - recusively checks for nested objects too (ex: <mark>expect( {p1:{n1:22, n2:23}} ).toMatchObject( {p1:{n2:23}} )</mark> will pass) <br>
        - does not work with Arrays (ex: <mark>expect( {p1:[1, 2]} ).toMatchObject( {p1:[1]} )</mark> will fail)
  </td>
</tr>
<tr class="25.03">
  <td> 
        toStrictEqual(<strong>data</strong>)
  </td>
  <td> 
        - the expected data should be equal <strong>data</strong> <u>(recursively checks the expected data (used to compare objects))</u> <br>
        - stricter version of <mark>toEqual</mark> (<mark>{}</mark> not equal <mark>{p1:undefined}</mark>, strict object check = class instances are not equal literal objects)
  </td>
</tr>
<tr class="55.01">
  <td> 
        toThrow(<i class="openable">err<div>
          <p> - thrown error object </p>
          <p> - the thrown error object's class (ex: <mark>Error</mark>) </p>
          <p> - the thrown error's message as a string </p>
          <p> - the thrown error's message as <strong>regExp</strong> </p>
        </div></i>)
  </td>
  <td> 
        - the expected data should be a function that optionally throws an error <u>(don't call the expected function, <mark>expect()</mark> will call it) 
  </td>
</tr>
<tr class="60.01">
  <td colspan="2"> Expect can be used in <mark>toEqual()</mark> / <mark>toBeCalledWith()</mark> matchers </td>
</tr>
<tr class="70.02">
  <td> 
        expect.any(<strong>constructor</strong>)
  </td>
  <td>
        - the expected value should be created by the <strong>constructor</strong>  
  </td>
</tr>
<tr class="70.01">
  <td> 
        expect.anything(<strong>val</strong>)
  </td>
  <td>
        - the expected value should NOT be <mark>undefined</mark> or <mark>null</mark> 
  </td>
</tr>
<tr class="65.02">
  <td> 
        expect<small>[.not]</small>.arrayContaining(<strong>arr</strong>)
  </td>
  <td>
        - the expect array should contain items in <strong>arr</strong> (shallow comparison)
  </td>
</tr>
<tr class="65.01">
  <td> 
        expect<small>[.not]</small>.objectContaining(<strong>obj</strong>)
  </td>
  <td>
        - the expected object should contain key/value pairs in <strong>obj</strong> (shallow comparison)
  </td>
</tr>
<tr class="60.02">
  <td> 
        expect<small>[.not]</small>.stringContaining(<strong>str</strong>)
  </td>
  <td>
        - expect value should contain <strong>str</strong> part
  </td>
</tr>
<tr class="60.03">
  <td> 
        expect<small>[.not]</small>.stringMatching(<strong>str|regExp</strong>)
  </td>
  <td>
        - the expect value should contain <strong>str|regExp</strong> part
  </td>
</tr>
</table>
  <br>
  
  
  
  
  
  
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <p> - I did not tested mock functions because I haven't find them usefull <a href="https://jestjs.io/docs/mock-functions" target="_blank">[link]</a> </p>
        <p> - concurrent (parallel) testing <mark>test.concurrent()</mark> is experimental [TESTED: 2021-07-31] </p>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://jestjs.io/" target="_blank">JestJs.io </a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
  <p> - Jest is a JavaScript testing framework </p>
  <pre class="syntax">
<span style="color:darkgray;">// <strong>fileName</strong>.test.js (file) ------------------------------------------------------------</span>
  test|it(<strong>testLabel:str</strong>, function(){                                                   // labeled test case (the <strong>testLabel</strong> is printed on CLI)   
    expect(<strong>exp</strong>).<strong>matcherMethod</strong>                                                          // the <strong>exp</strong> is the case what we want to test, the <strong>matcherMethod</strong> checks to outcome   
  })
  </pre>
<details class="example"> 
<summary> DEMO </summary>
  <p> - <mark>jest.test.js</mark> (file) </p>
  <pre>
  test('addition check-1', function(){
    expect(1 + 1).toBe(2)                                                              // test passes 
  })
  
  test('addition check-2', function(){
    expect(1 + 1).toBe(3)                                                              // test fails 
  })
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> coverage test </u></h4>
  <p> - <mark>myTest.test.js</mark> file </p>
  <pre>
  const {myFn1, myFn2} = require('./testFn')
  
  test('should run imported functions', function(){
    expect(myFn1()).toBe(5)
    expect(myFn2()).toBe(7)
    
  })
  </pre>
  <p> - <mark>testFn.js</mark> file </p>
  <pre>
  function myFn1(){
    let x = 2;
    let y = 3;
    const result = x + y
    
    return result
  }
  
  function myFn2(){
    let x = 7
    let y = 8
    const result = x + y
    
    return result
  }
  
  module.exports = {
    myFn1,
    myFn2
  }
  </pre>
  <pre class="cmd">
  pall@Aspire:~/Documents/CodePlus/My Site/Jest/TEST$ jest --coverage
    PASS  ./myTest.test.js
      ✓ should run imported functions (4 ms)
      
    -----------|---------|----------|---------|---------|-------------------
    File       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s 
    -----------|---------|----------|---------|---------|-------------------
    All files  |     100 |      100 |     100 |     100 |                   
    testFn.js  |     100 |      100 |     100 |     100 |                   
    -----------|---------|----------|---------|---------|-------------------
    Test Suites: 1 passed, 1 total
    Tests:       1 passed, 1 total
    Snapshots:   0 total
    Time:        0.472 s, estimated 1 s
    Ran all test suites.
  pall@Aspire:~/Documents/CodePlus/My Site/Jest/TEST$ 
  </pre>
</details>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h2 style="color:darkblue;"><u> Testing Asynchronous code </u></h2>
  <pre class="syntax">
<span style="color:darkgray;">// asynchronous callback --------------------------------------------------------------</span>
  test(<strong>testLabel:str</strong>, function(done){                                                  // the <mark>done</mark> callback will signal the end of an async task   
    function <strong>callback</strong>(){
      expect(<strong>something</strong>).<strong>matcherMethod</strong>                                                  // we verify the async returned result 
      done()                                                                           // signals the end of the async task   
    }
    
    someAsyncApi(<strong>callback</strong>)                                                             // calling the async api 
  })
  
  
<span style="color:darkgray;">// promises ---------------------------------------------------------------------------</span>
  test(<strong>testLabel:str</strong>, function(){
    return <strong>promise</strong>                                                                     // promises must be returned 
  })
  
  
  test(<strong>testLabel:str</strong>, function(){
    return expect(<strong>promise</strong>).resolves.<strong>matcherMethod</strong>                                      // the <mark>.resolves</mark> expects a resolved promise    
    
    return expect(<strong>promise</strong>).rejects.<strong>matcherMethod</strong>                                       // the <mark>.rejects</mark> expects a rejected promise    
  })
  
  
<span style="color:darkgray;">// async functions --------------------------------------------------------------------</span>
  test(<strong>testLabel:str</strong>, async function(){
    await <strong>promise</strong>                                                                      // waits the promise to be resolved or rejected 
    
    await expect(<strong>promise</strong>).resolves.<strong>matcherMethod</strong>                                       // we can directly write a test after the await 
    await expect(<strong>promise</strong>).rejects.<strong>matcherMethod</strong> 
  })
  </pre>
<details class="example">
<summary> DEMO </summary>
  <p> - asynchronous callback </p>
  <pre>
  const fs = require('fs')
  
  test('should read file', function(done){
    function cb(err, data){
      expect(data.toString()).toBe('test file content')
      done()                                                                           // the doen callback signals the end of an async task 
    }
    
    fs.readFile('testFile.txt', cb)
  })
  </pre>
  <p> - promises </p>
  <pre>
  const fs = require('fs').promises
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')
  
  test('should read file', function(){
    return fs.readFile('./testFile.txt')                                               // promises should be returned 
      .then((res) => {
        expect(res.toString()).toBe('test file content')
      })
  })
  
// ------------------------------------------------------------------------------------
  test('should resolve promise', function(){
    return expect(resPromise).resolves.toBe('res')                                     // the '.resolves' property expects a resolved promise result  
  })
  
  test('should reject promise', function(){
    return expect(rejPromise).rejects.toBe('rej')                                      // the '.rejects' property expects a rejected promise result  
  })
  </pre>
  <p> - async function </p>
  <pre>
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')
  
  test('async test', async function(){
    await expect(resPromise).resolves.toBe('res')                                      // waits for the promise then tests the result directly   
    await expect(rejPromise).rejects.toBe('rej')
  })
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> testing async code </u></h4>
  <p> - both cases work fine, however the jest specification says that the <mark>done</mark> callback should be used for accurate testing </p>
  <pre>
  const fs = require('fs')
  
// -------------------------------------------------------------------------
  test('should read file', function(){
    function cb(err, data){
      expect(data.toString()).toBe('test file content')
    }
    
    fs.readFile('testFile.txt', cb)
  })
  
// -------------------------------------------------------------------------
  test('should read file', function(done){
    function cb(err, data){
      expect(data.toString()).toBe('test file content')
      done()
    }
    
    fs.readFile('testFile.txt', cb)
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> testing promisses </u></h4>
  <pre>
  const fs = require('fs').promises
  
  test('should read file', function(){
    return fs.readFile('./testFile.txt')
      .then((res) => {
        expect(res.toString()).toBe('test file content')
      })
  })
  </pre>
  <pre>
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')
  
  test('should resolve promise', function(){
    return expect(resPromise).resolves.toBe('res')
  })
  
  test('should reject promise', function(){
    return expect(rejPromise).rejects.toBe('rej')
  })
  </pre>
  <p> - async functions </p>
  <pre>
  const resPromise = Promise.resolve('res')
  const rejPromise = Promise.reject('rej')

  test('async test', async function(){
    await expect(resPromise).resolves.toBe('res')
    await expect(rejPromise).rejects.toBe('rej')
  })
  </pre>
</details>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h2 style="color:darkblue;"><u> Scopes and Teardown </u></h2>
<h3 style="color:darkblue;"><u> Scope Methods <mark>describe()</mark> / <mark>describe.skip()</mark> / <mark>describe.only()</mark> / <mark>describe.each()()</mark> / <mark>describe.skip.each()()</mark> / <mark>describe.only.each()()</mark> </u></h3>
<h3 style="color:darkblue;"><u> Teardown Methods <mark>beforeEach()</mark> / <mark>afterEach()</mark> / <mark>beforeAll()</mark> / <mark>afterAll()</mark>  </u></h3>
  <p> - we can scope our test so test suites are isolated from each other, in Jest scopes are executed from top-to-bottom (not nesting execution order) </p>
  <p> - teardown methods execute their functions at the desired time </p>
<details class="example"> 
<summary> DEMO </summary>
  <p> - scope methods </p>
  <pre>
// describe() -------------------------------------------------------------------------
  describe('desc-main-1', function(){                                                  // describe scopes are isolated from each other and executed from top-to-bottom 
    // some here ...                                                                   // the execution order here is 'desc-main-1' | 'desc-nest' | 'desc-main-2'
    
    describe('desc-nest', function(){
      // some test ...
    })
  })
  
  describe('desc-main-2', function(){
    // some test ...
  })
  
// describe.only() --------------------------------------------------------------------
  describe('desc-1', function(){
    // some test ...
  })
  
  describe.only('desc-2', function(){                                                  // only this describe scope is executed ('desc-1' describe scope is ignored)
    // some test ...
  })
  
// describe.skip() -------------------------------------------------------------------
  describe('desc-1', function(){
    // some test ...
  })
  
  describe.skip('desc-2', function(){                                                  // skips this describe scope ('desc-1' describe scope an all other scopes are executed)
    // some test ...
  })
  
  
// describe.each()() ------------------------------------------------------------------
  describe.each(['desc-1', 'desc-2', 'desc-3'])('name: %s', function(){                // runs 3 describe scopes (%s = is the name of the current scope)
    // some test ...                                                                   // 3 decribe scope names will be 'name :desc-1' | 'name :desc-2' | 'name :desc-3'
  })
  
// describe.only.each()() -------------------------------------------------------------
  describe('desc-1', function(){
    // some test ...
  })
  
  describe.only.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // only this describe each is executed ('desc-1' describe scope is ignored)
    // some test ...
  })
  
// describe.skip.each()() -------------------------------------------------------------
  describe('desc-1', function(){
    // some test ...
  })
  
  describe.skip.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // skips these describe each scopes ('desc-1' describe scope an all other scopes are executed)
    // some test ...
  })
  </pre>
  <p> - teardown methods </p>
  <pre>
// beforeEach() / afterEach() ---------------------------------------------------------
  beforeEach(function(){                                                               // runs its function before each test in this scope   
    // some test ...
  })
  
  afterEach(function(){                                                                // runs its function after each test in this scope   
    // some test ...
  })
  
// beforeAll() / afterAll() -----------------------------------------------------------
  beforeAll(function(){                                                                // runs its function (once) before all tests in this scope   
    // some test ...
  })
  
  afterAll(function(){                                                                 // runs its function (once) before all tests in this scope   
    // some test ...
  })
  
  // other tests ...
  
  // other tests ...
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> scope calling order TEST </u></h4>
  <p> - <mark>describe</mark> scopes are called form top-to-bottom </p>
  <pre>
  describe('main', function(){
    it('someTest', function(){})
    
    describe('nest-1', function(){
      it('someTest', function(){})

      describe('nest-nest-1', function(){
        it('someTest', function(){})
      })
    })
    
    describe('nest-2', function(){
      it('someTest', function(){})
      
      describe('nest-nest-2', function(){
        it('someTest', function(){})
      })
    })
  })
  </pre>
  <pre class="cmd">
  pall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ ./node_modules/.bin/jest 
    PASS  ./myTest.test.js
      main
        ✓ someTest (1 ms)
        nest-1
          ✓ someTest
          nest-nest-1
            ✓ someTest
        nest-2
          ✓ someTest
          nest-nest-2
            ✓ someTest

    Test Suites: 1 passed, 1 total
    Tests:       5 passed, 5 total
    Snapshots:   0 total
    Time:        0.179 s, estimated 1 s
    Ran all test suites.
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ 
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>describe.only()</mark> / <mark>describe.skip()</mark> / <mark>describe.each()</mark> / <mark>describe.skip.each()</mark> / <mark>describe.only.each()</mark> / <mark>describe.skip.each()</mark> TEST </u></h4>
<hr>
  <pre>
// describe.each()() ------------------------------------------------------------------
  describe.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){                 // runs 3 describe scopes (%s = is the name of the current scope)
    test('test', function(){})
  })
  
// describe.only() --------------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })
  
  describe.only('desc-2', function(){                                                  // only this describe scope is executed 
    test('test', function(){})
  })
  
  describe('desc-3', function(){
    test('test', function(){})
  })
  
// describe.sip() --------------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })
  
  describe.skip('desc-2', function(){                                                  // skips this describe scope 
    test('test', function(){})
  })
  
  describe('desc-3', function(){
    test('test', function(){})
  })
  
// describe.only.each()() -------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })
  
  describe.only.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // only this describe each is executed 
    test('test', function(){})
  })
  
  describe('desc-3', function(){
    test('test', function(){})
  })
  
// describe.skip.each()() -------------------------------------------------------------
  describe('desc-1', function(){
    test('test', function(){})
  })

  describe.skip.each(['des-1', 'desc-2', 'desc-3'])('name: %s', function(){            // skips these describe each scopes 
    test('test', function(){})
  })

  describe('desc-3', function(){
    test('test', function(){})
  })
  </pre>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>beforeEach()</mark> / <mark>afterEach()</mark> / <mark>beforeAll()</mark> / <mark>afterAll()</mark> TEST </u></h4>
  <pre>
  beforeEach(function(){
    console.log( 'before-each')
  })
  afterEach(function(){
    console.log( 'after-each')
  })

  beforeAll(function(){
    console.log( 'before-all')
  })
  afterAll(function(){
    console.log( 'after-all')
  })

  test('test-1', function(){
    console.log( 'test-1' )
  })
  test('test-2', function(){
    console.log( 'test-2' )
  })
  </pre>
  <pre class="cmd">
  pall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ ./node_modules/.bin/jest 
    PASS  ./myTest.test.js
      ✓ test-1 (2 ms)
      ✓ test-2 (1 ms)
      console.log
        before-all
          at myTest.test.js:9:11
      console.log
        before-each
          at Object.<anonymous> (myTest.test.js:2:11)
      console.log
        test-1
          at Object.<anonymous> (myTest.test.js:16:11)
      console.log
        after-each
          at Object.<anonymous> (myTest.test.js:5:11)
      console.log
        before-each
          at Object.<anonymous> (myTest.test.js:2:11)
      console.log
        test-2
          at Object.<anonymous> (myTest.test.js:19:11)
      console.log
        after-each
          at Object.<anonymous> (myTest.test.js:5:11)
      console.log
        after-all

          at myTest.test.js:12:11

    Test Suites: 1 passed, 1 total
    Tests:       2 passed, 2 total
    Snapshots:   0 total
    Time:        0.189 s, estimated 1 s
    Ran all test suites.
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ 
  </pre>
  
  
  
  
  
  
  
  
  
  // describe.each(table)()
      - runs a describe scope for each item in the table
  // describe.only()
      - only runs this describe block 
  // describe.only.each(table)()
      - only runs this describe each 
  // describe.skip()
      - skips this describe scope 
  // describe.skip.each()
      - skips this each describe scope  
  
  
  
  
  
</details>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h2 style="color:darkblue;"><u> Test cases </u></h2>
<h3 style="color:darkblue;"><u> Methods <mark>test()</mark> / <mark>test.only()</mark> / <mark>test.skip()</mark> / <mark>test.each()()</mark> / <mark>test.only.each()()</mark> / <mark>test.skip.each()()</mark> / <mark>test.todo()</mark> </u></h3>
<details class="example"> 
<summary> DEMO </summary>
  <pre>
  test('some test', function(){
    // expect test case here...
  })
  
// test.only() ------------------------------------------------------------------------
  test.only('some test', function(){                                                   // only this test case is executed in this jest file   
    // expect test case here...
  })
  
// test.skip() ------------------------------------------------------------------------
  test.skip('some test', function(){                                                   // this test case is skipped 
    // expect test case here...
  })
  
// test.each() ------------------------------------------------------------------------
  test.each([1, 2, 3])('test-%d', function(){                                          // executes the test case function 3 times for each item  ('test-1' | 'test-2' 'test-3') 
    // expect test case here...
  })
  
// test.only.each() -------------------------------------------------------------------
  test.only.each([1, 2, 3])('test-%d', function(){                                     // only these test cases will be executed in this jest file 
    // expect test case here...
  })
  
// test.skip.each() -------------------------------------------------------------------
  test.skip.each([1, 2, 3])('test-%d', function(){                                     // these test cases will be skipped 
    // expect test case here...
  })
  
// test.todo() ------------------------------------------------------------------------
  test('test-1', () => {})
  test('test-2', () => {})
  test('test-3', () => {})
  
  test.todo('we should do 5 tests')                                                    // this is basically a note which is printed at the end of the test cases in the output  
  
  test('test-4', () => {})
  test('test-5', () => {})
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style='color:darkblue'><u> <mark>test()</mark> / <mark>test.only()</mark> / <mark>test.skip()</mark> TEST </u></h4>
  <pre>
  test('test-1', function(){
    console.log( 'test1')
  })
  
// ------------------------------------------------------------------------------------
  test.only('test2', function(){                                                       // only this test case is executed in this jest file   
    console.log( 'test2')
  })
  
// ------------------------------------------------------------------------------------
  test.skip('test3', function(){                                                       // this test case is skipped 
    console.log( 'test2')
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style='color:darkblue'><u> <mark>test.eac()</mark> / <mark>test.only.each()</mark> / <mark>test.skip.each()</mark> TEST </u></h4>
  <pre>
  test.each([1, 2, 3])('test-%d', function(){
    console.log( 'test')                                                               // 3 test cases are executed here 
  })
  
// ------------------------------------------------------------------------------------
  test.only.each([1, 2, 3])('test-%d', function(){                                     // only these test cases will be executed in this jest file 
    console.log( 'test')
  })
  
// ------------------------------------------------------------------------------------
  test.skip.each([1, 2, 3])('test-%d', function(){                                     // these test cases will be skipped 
    console.log( 'test')
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style='color:darkblue'><u> <mark>test.todo()</mark> TEST </u></h4>
  <pre>
  test('test-1', () => {})
  test('test-2', () => {})
  test('test-3', () => {})
  
  test.todo('we should have 4 tests')
  
  test('test-4', () => {})
  
  test.todo('ok we have 4 tests now')  
  </pre>
  <pre class="cmd">
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$ ./node_modules/.bin/jest
    PASS  ./myTest.test.js
      ✓ test-1
      ✓ test-2
      ✓ test-3
      ✓ test-4 (1 ms)
      ✎ todo we should have 4 tests
      ✎ todo ok we have 4 tests now
    
    Test Suites: 1 passed, 1 total
    Tests:       2 todo, 4 passed, 6 total
    Snapshots:   0 total
    Time:        0.181 s, estimated 1 s
    Ran all test suites.
  apall@apall-notebook:~/Documents/Pall's Stuff/CodePlus/My Site/Jest/TEST$  
  </pre>
</details>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h2 style="color:darkblue;"><u> Expect and Matchers  </u></h2>
<h3 style="color:darkblue"><u> Expect <mark>expect()</mark> / <mark>expect.extend()</mark> / <mark>expect.assertions()</mark> / <mark>expect.hasAssertions()</mark> / <mark>expect.stringContaining()</mark> / <mark>expect.stringMatching()</mark> / <mark>objectContaining()</mark> / <mark>arrayContaining()</mark> / <mark>expect.anything()</mark> / <mark>expect.any()</mark> </u></h3>
<h3 style="color:darkblue;"><u> Matchers <mark>not</mark> / <mark>toBe()</mark> / <mark>toEqual()</mark> / <mark>toStrictEqual()</mark> / <mark>toBeNull()</mark> / <mark>toBeNaN</mark> / <mark>toBeUndefined()</mark> / <mark>toBeDefined()</mark> / <mark>toBeTruthy()</mark> / <mark>toBeFalsy()</mark> / <mark>toBeGreaterThan()</mark> / <mark>toBeGreaterThanOrEqual()</mark> / <mark>toBeLessThan()</mark> / <mark>toBeLessThanOrEqual()</mark> / <mark>toBeCloseTo()</mark> / <mark>toMatch()</mark> / <mark>toMatchObject</mark> / <mark>toContain()</mark> / <mark>toContainEqual()</mark> / <mark>toHaveLength()</mark> / <mark>toHaveProperty()</mark> / <mark>toBeInstanceOf()</mark> / <mark>toThrow()</mark>  </u></h3>
<details class="example"> 
<summary> DEMO </summary>
  <pre>
// expect.extend() --------------------------------------------------------------------
  expect.extend({
    toBeNotString(received){                                                           // creating a custom matcher method 
      if(typeof received !== 'string'){
        return {pass:true, message:() => 'not a string data type'}
      } else {
        return {pass:false, message:() => `${received} is a string data type`}
      }
    }
  })
  
  test('should not be a string', function(){
    expect(21).toBeNotString()                                                         // test passes     // custom matcher method used   
    expect('21').toBeNotString()                                                       // test fails 
  })
  
  
// expect.objectContaining() ----------------------------------------------------------
  test('obj containing-1', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p2:22}))                   // test passes 
  })
  
  test('obj containing-2', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p1:21, p2:22, p3:23}))     // test fails (expected object does not contain 'p3:23')
  })
  
  test('obj containing-3', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({nest:22}))          // test fails 
  })
  
  test('obj containing-4', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({p2:{nest:22}}))     // test passes  
  })
  
  
// expect.arrayContaining() -----------------------------------------------------------
  test('array containing-1', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  }) 
  
  test('array containing-2', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  })
  
  
// expect.anything() ------------------------------------------------------------------
  test('anything-1', function(){
    expect(0).toEqual(expect.anything())                                               // test passes
    expect('str').toEqual(expect.anything())                                           // test passes 
    expect(undefined).toEqual(expect.anything())                                       // test fails
  })
  
  
// expect.any() -----------------------------------------------------------------------
  test('any-1', function(){
    expect(12).toEqual(expect.any(Number))                                             // test passes 
    
    function Animal(race){
      this.race = race
    }
    
    var cat = new Animal('cat')
    
    expect(cat).toEqual(expect.any(Animal))                                            // test passes 
  })
  
  
// expect.assertions() / expect.hasAssertions() ---------------------------------------  
  const myTimeout = new Promise(function(res, rej){
    setTimeout(function(){
      res('timeout promise OK!')
    }, 2000)
  })
  
  test('assert test-1', async function(){
    expect.assertions(2)                                                               // 2 assertions in this test => test passes 
    
    expect(2**2).toBe(4)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // also works with async code 
  })
  
  test('assert test-1', async function(){
    expect.hasAssertions()                                                             // test should have at least 1 assertion
    
    expect(2**2).toBe(4)
    expect(2**4).toBe(16)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // also works with async code 
  })
  </pre>
  <pre>
// not --------------------------------------------------------------------------------
  test('test', function(){
    expect(2).not.toBe(3)                                                              // test passes 
    expect(2).not.toBe(2)                                                              // test fails 
  })
  
// toBe() / toEqual() -----------------------------------------------------------------
  test('test', function(){
    expect(2).toBe(2)                                                                  // test passes 
    expect(2).toBe('2')                                                                // test fails because the toBe() uses the same value comparison operator (===)
    expect({p1:21, p2:22}).toBe({p1:21, p2:22})                                        // test fails because the toBe() cannot compare objects 
  })
  
  test('test', function(){
    expect({p1:21, p2:22}).toEqual({p1:21, p2:22})                                     // test passes (recursively compares object properties)
    expect([1, 2, 3]).toEqual([1, 2, 3])                                               // test passes 
  })
  
// toEqual() VS toStrictEqual() -------------------------------------------------------
  class TestClass {
    constructor(a, b){
      this.a = a
      this.b = b;
    }
  }
  
  var myObj = new TestClass(21, 22)
  
  test('test', function(){
    expect({}).toEqual({p1:undefined})                                                 // test passes 
    expect([,1]).toEqual([undefined,1])                                                // test passes 
    expect({a:21, b:22}).toEqual(myObj)                                                // test passes
  })
  
  test('test-2', function(){
    expect({}).toStrictEqual({p1:undefined})                                           // the 'toStrictEqual()' is a stricter version of 'toEqual' all these tests will fail    
    expect([,1]).toStrictEqual([undefined,1]) 
    expect({a:21, b:22}).toStrictEqual(myObj) 
  })
  
// toBeNull() / toBeNaN() / toBeUndefined() / toBeDefined() / toBeTruthy() / toBeFalsy() --
  test('test', function(){
    expect(null).toBeNull()                                                            // test passes 
    
    expect(NaN).toBeNaN()                                                              // test passes 
    
    expect(undefined).toBeUndefined()                                                  // test passes 
    expect('').toBeDefined()                                                           // test passes (any value which is not undefined) 
    
    expect(1).toBeTruthy()                                                             // test passes 
    expect(0).toBeFalsy()                                                              // test passes 
  })
  
// toBeGreaterThan() / toBeGreaterThanOrEqual() / toBeLessThan() / toBeLessThanOrEqual() / toBeCloseTo() --
  test('test', function(){
    expect(5).toBeGreaterThan(3)                                                       // test passes 
    expect(5).toBeGreaterThanOrEqual(3)                                                // test passes 
    expect(5).toBeGreaterThanOrEqual(5)                                                // test passes 
    
    expect(5).toBeLessThan(7)                                                          // test passes   
    expect(5).toBeLessThanOrEqual(7)                                                   // test passes   
    expect(5).toBeLessThanOrEqual(5)                                                   // test passes   
    
    expect(0.1 + 0.2).toBeCloseTo(0.3)                                                 // test passes (used for double floating comparison)   
  })
  
// toMatch() / toMatchObject() --------------------------------------------------------
  test('test', function(){
    expect('some test').toMatch('some test')                                           // test passes 
    expect('some test').toMatch(/SOME TEST/i)                                          // test passes (also accepts regular expressions)
  })
  
  test('test', function(){
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222}}).toMatchObject({p1:21})           // test passes 
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222}}).toMatchObject({p2:{b:2}})        // test passes (also check for nested objects)
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222}}).toMatchObject({p3:{nest2:222}})  // test passes 
    
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2]})                                          // test fails (does not work with Arrays)
    
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2, 3]})                                       // test passes (the nested Array has the same structure as in the expected object)    
  })
  
// toHaveLength() / toContain() / toContainEqual() ------------------------------------
  test('test', function(){
    expect([1, 2, 3]).toHaveLength(3)                                                  // test passes 
    expect('some string').toHaveLength(11)                                             // test passes 
  })
  
  test('test', function(){
    expect([1, 2, 3]).toContain(2)                                                     // test passes (Array contains the item)
    expect(['egy', 'ketto', 'harom']).toContain('ketto')                               // test passes 
    expect('some string').toContain(' ')                                               // test passes 
  })
  
  test('test', function(){
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p3:33})           // test passes (the expected array contains the item)
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({nest:[1, 2]})     // test passes 
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21, p2:22})    // test passes 
    
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21})           // test fails 
    expect({p1:21, p2:22, p3:[1, 2]}).toContainEqual({p2:22})                          // test fails (object is not expected)
  })
  
// toHaveProperty() / toBeInstanceOf() ------------------------------------------------
  test('test', function(){
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p1')                                   // test passes 
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p2.n1')                                // test passes (we can check for nested properties)
    expect({p1:21, p2:{n1:33, n2:{d1:true}}}).toHaveProperty('p2.n2.d1')               // test passes 
  })
  
  test('test', function(){
    expect({p1:21}).toBeInstanceOf(Object)                                             // test passes 
    expect([1, 2]).toBeInstanceOf(Array)                                               // test passes 
    expect(/./).toBeInstanceOf(RegExp)                                                 // test passes 
    
    class SomeClass {}
    let myInstance = new SomeClass()
    
    expect(myInstance).toBeInstanceOf(SomeClass)                                       // test passes 
  })
  
// toThrow() --------------------------------------------------------------------------
  function testFn(){
    throw new Error('someError')
  }
    
  test('test', function(){
    expect(testFn).toThrow()                                                           // test passes 
    expect(testFn).toThrow('someError')                                                // test passes 
    expect(testFn).toThrow(/someError/)                                                // test passes 
    expect(testFn).toThrow(Error)                                                      // test passes (the thrown error is an instance of this class)
  })
  </pre>
</details>
<details class="example"> 
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>expect.extend()</mark> TEST </u></h4>
  <pre>
  expect.extend({
    toBeBiggerThan0(received){
      if(received > 0){
        return {
          pass: true,
          message: () => 'bigger than 0'
        }
      } else {
        return {
          pass: false,
          message: () => 'smaller or equal 0'
        }
      }
    },
    toBeInRangeOf(received, min, max){
      if(received >= min && received &lt;= max){
        return {
          pass: true,
          message: () => `${received} is in range of min ${min} max ${max}`
        }
      } else {
        return {
          pass: false,
          message: () => `${received} is not in range of min ${min} max ${max}`
        }
      }
    }
  })
  
  test('should be bigger than 0', function(){
    expect(42).toBeBiggerThan0()                                                       // test passes 
  })
  
  test('should be bigger than 0', function(){
    expect(-8).toBeBiggerThan0()                                                       // test fails
  })
  
  test('should be in range', function(){
    expect(10).toBeInRangeOf(5, 15)                                                    // test passes 
  })
  
  test('should be in range', function(){                                               // test fails  
    expect(10).toBeInRangeOf(11, 25)
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>expect.assertions()</mark> / <mark>expect.hasAssertions()</mark> TEST </u></h4>
  <pre>
  const myTimeout = new Promise(function(res, rej){
    setTimeout(function(){
      res('timeout promise OK!')
    }, 2000)
  })
  
  test('assert test-1', async function(){
    expect.assertions(2)                                                               // 2 assertions in this test => test passes 
    
    expect(2**2).toBe(4)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // assertios() also works with async code 
  })
  
  test('assert test-1', async function(){
    expect.hasAssertions()                                                             // test should have at least 1 assertion
    
    expect(2**2).toBe(4)
    expect(2**4).toBe(16)
    await expect(myTimeout).resolves.toBe('timeout promise OK!')                       // assertios() also works with async code 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>expect.stringContaining()</mark> / <mark>expect.StringMatching()</mark> TEST </u></h4>
  <pre>
  test('some test-1', function(){
    expect('Kicsi kutya tarka').toEqual(expect.stringContaining('kutya'))              // test passes 
    expect('Kicsi kutya tarka').toEqual(expect.stringContaining('macka'))              // test fails 
  })
  
  test('some test-2', function(){
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching('ta'))                   // test passes 
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching(/k.cs.\s/i))             // test passes 
    
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching('farka'))                // test fails
    expect('Kicsi kutya tarka').toEqual(expect.stringMatching(/k.cs.\s/))              // test fails 
  })
  
  const mock = jest.fn()
  
  function testFn(a, b, cb){
    cb(a, b)
  }
  
  test('mock called with', function(){
    testFn('one', 'two', mock)
    
    expect(mock).toBeCalledWith(expect.stringContaining('one'), expect.stringContaining('two'))   // test passes 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>expect.objectContaining()</mark> / <mark>expectArrayContaining()</mark> TEST </u></h4>
  <pre>
// expect.objectContaining() ----------------------------------------------------------
  test('obj containing-1', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p2:22}))                   // test passes 
  })
  
  test('obj containing-2', function(){
    expect({p1:21, p2:22}).toEqual(expect.objectContaining({p1:21, p2:22, p3:23}))     // test fails (expected object does not contain 'p3:23')
  })
  
  test('obj containing-3', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({nest:22}))          // test fails 
  })
  
  test('obj containing-4', function(){
    expect({p1:21, p2:{nest:22}}).toEqual(expect.objectContaining({p2:{nest:22}}))     // test passes  
  })
  
  // expect.arrayContaining() ---------------------------------------------------------
  test('array containing-1', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  }) 
  
  test('array containing-2', function(){
    expect([1, 2, 3, 4, 5]).toEqual(expect.arrayContaining([2, 5]))                    // test passes  
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>expect.anything()</mark> / <mark>expect.any()</mark> TEST </u></h4>
  <pre>
// expect.anything() ------------------------------------------------------------------
  test('anything-1', function(){
    expect(0).toEqual(expect.anything())                                               // test passes
    expect('str').toEqual(expect.anything())                                           // test passes 
  })
  
  test('anything-2', function(){
    expect(undefined).toEqual(expect.anything())                                       // test fails
  })
  
  test('anything-3', function(){
    expect(null).toEqual(expect.anything())                                            // test fails
  })
    
// expect.any() -----------------------------------------------------------------------
  test('any-1', function(){
    expect(12).toEqual(expect.any(Number))                                             // test passes 
  })
  
  test('any-2', function(){
    function Animal(race){
      this.race = race
    }
    
    var cat = new Animal('cat')
    
    expect(cat).toEqual(expect.any(Animal))                                            // test passes 
  })
  
  test('any-3', function(){
    expect(/r/).toEqual(expect.any(RegExp))                                            // test passes 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>toBe()</mark> / <mark>toEqual()</mark> / <mark>toStrictEqual()</mark> TEST </u></h4>
  <pre>
  test('test-1', function(){
    expect(2).toBe('2')                                                                // test fails because the toBe() uses the same value comparison operator (===)
  })
  
  test('test-2', function(){
    expect(2).toBe(2)                                                                  // test passes 
  })
  
  test('test-3', function(){
    expect({p1:21, p2:22}).toBe({p1:21, p2:22})                                        // test fails because the toBe() can compare only values   
  })
  
  test('test-3', function(){
    expect({p1:21, p2:22}).toEqual({p1:21, p2:22})                                     // test passes because the toEqual() recursively compares object properties 
  })
  
  test('test-4', function(){
    expect([1, 2, 3]).toBe([1, 2, 3])                                                  // test fails because the toBe() can compare only values
  })
  
  test('test-', function(){
    expect([1, 2, 3]).toEqual([1, 2, 3])                                               // test fails because the toBe() can compare only values   
  })
  </pre>
  <p> - <mark>toEqual()</mark> VS <mark>toStrictEqual()</mark> </p>
  <pre>
  class TestClass {
    constructor(a, b){
      this.a = a
      this.b = b;
    }
  }
  
  var myObj = new TestClass(21, 22)
  
// toEqual() --------------------------------------------------------------------------
  test('test-1', function(){
    expect({}).toEqual({p1:undefined})                                                 // test passes 
    
    expect([,1]).toEqual([undefined,1])                                                // test passes 
    
    expect({a:21, b:22}).toEqual(myObj)
  })
  
  
// toStrictEqual() --------------------------------------------------------------------
  test('test-2', function(){
    expect({}).toStrictEqual({p1:undefined})                                           // test fails  
  })
  
  test('test-3', function(){
    expect([,1]).toStrictEqual([undefined,1])                                          // test fails
  })

  test('test-4', function(){
    expect({a:21, b:22}).toStrictEqual(myObj)                                          // test fails
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>.not</mark> TEST </u></h4>  
  <pre>
  test('test-1', function(){
    expect(2).not.toBe(3)                                                              // test passes 
  })
  
  test('test-2', function(){
    expect(2).not.toBe(2)                                                              // test fails 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>.toThrow()</mark> TEST </u></h4>  
  <pre>
  function testFn(){
    throw new Error('someError')
  }
    
  test('test-1', function(){
    expect(testFn).toThrow()                                                           // the function instance is not called!
    
    expect(testFn).toThrow('someError')
    
    expect(testFn).toThrow(/someError/)
    
    expect(testFn).toThrow(Error)
  })
  </pre>
<h4 style="color:darkblue;"><u> <mark>toBeNull()</mark> / <mark>toBeNaN()</mark> / <mark>toBeUndefined()</mark> / <mark>toBeDefined()</mark> / <mark>toBeTruthy()</mark> / <mark>toBeFalsy()</mark> TEST </u></h4>  
  <pre>
  test('test-1', function(){
    expect(null).toBeNull()  
    
    expect(NaN).toBeNaN()
    
    expect(undefined).toBeUndefined()
    expect('').toBeDefined()                                                           // any value which is not undefined 
    
    expect(1).toBeTruthy()
    expect(0).toBeFalsy()
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>toBeGreaterThan()</mark> / <mark>toBeGreaterThanOrEqual()</mark> / <mark>toBeLessThan()</mark> / <mark>toBeLessThanOrEqual()</mark> / <mark>toBeCloseTo()</mark> TEST </u></h4>  
  <pre>
  test('test-1', function(){
    expect(5).toBeGreaterThan(3)  
    expect(5).toBeGreaterThanOrEqual(3)  
    expect(5).toBeGreaterThanOrEqual(5)  
    
    expect(5).toBeLessThan(7)
    expect(5).toBeLessThanOrEqual(7)
    expect(5).toBeLessThanOrEqual(5)
    
    expect(0.1 + 0.2).toBeCloseTo(0.3)                                                 // for double floating comparison 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>toMatch()</mark> / <mark>toMatchObject()</mark> TEST </u></h4>  
  <pre>
// toMatch() --------------------------------------------------------------------------
  test('test-1', function(){
    expect('some test').toMatch('some test')
    expect('some test').toMatch(/SOME TEST/i)                                          // also accepts regular expressions  
  })
  
// toMatchObject() --------------------------------------------------------------------
  test('test-2', function(){
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222, nest3:['str']}}).toMatchObject({p1:21})
    
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222, nest3:['str']}}).toMatchObject({p2:{b:2}})
    
    expect({p1:21, p2:{a:1, b:2}, p3:{nest1:111, nest2:222, nest3:['str']}}).toMatchObject({p3:{nest2:222}})
  })
  
  test('test-3', function(){
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2]})                                  // test fails (this matcher works with nested objects only) 
  })
  
  test('test-4', function(){
    expect({p1:[1, 2, 3]}).toMatchObject({p1:[1, 2, 3]})                               // test passes (the nested item has the same structure as in the expected object) 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>toHaveLength()</mark> / <mark>toContain()</mark> / <mark>toContainEqual()</mark> TEST </u></h4>  
  <pre>
// toHaveLength() ---------------------------------------------------------------------
  test('test-1', function(){
    expect([1, 2, 3]).toHaveLength(3)
    
    expect('some string').toHaveLength(11)
  })
  
// toContain() ------------------------------------------------------------------------
  test('test-2', function(){
    expect([1, 2, 3]).toContain(2)
    
    expect(['egy', 'ketto', 'harom']).toContain('ketto')
    
    expect('some string').toContain(' ')
  })
  
// toContainEqual() -------------------------------------------------------------------
  test('test-3', function(){
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p3:33})
    
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({nest:[1, 2]})
    
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21, p2:22})
  })
  
  test('test-4', function(){
    expect([{p1:21, p2:22}, {nest:[1, 2]}, {p3:33}]).toContainEqual({p1:21})           // test fails the array item must have a specific structure 
  })
  
  test('test-5', function(){
    expect({p1:21, p2:22, p3:[1, 2]}).toContainEqual({p2:22})                          // test fails this matcher expects an Array 
  })
  </pre>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h4 style="color:darkblue;"><u> <mark>toHaveProperty()</mark> / <mark>toBeInstanceOf()</mark> TEST </u></h4>  
  <pre>
  // toHaveProperty() ---------------------------------------------------------
  test('test-1', function(){
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p1')
    expect({p1:21, p2:{n1:33}}).toHaveProperty('p2.n1')
    expect({p1:21, p2:{n1:33, n2:{d1:true}}}).toHaveProperty('p2.n2.d1')
  })
  
// toBeInstanceOf() ---------------------------------------------------------
  test('test-2', function(){
    expect({p1:21}).toBeInstanceOf(Object)
    expect([1, 2]).toBeInstanceOf(Array)
    
    class SomeClass {}
    let myInstance = new SomeClass()
    
    expect(myInstance).toBeInstanceOf(SomeClass)
  })
  </pre>
</details>
<hr>
<!------------------------------------------------------------------------------------------------------>
<h2><u> Mocking and Spying </u></h2>
<h2 style="color:darkblue;"><u> Mock Functions  </u></h2>
  <pre>
  
  </pre>
  
  
  
  
<details class="example" open> 
<summary> DEMO </summary>
  
  
  
</details>
  
<details class="example" open> 
<summary> Example : </summary>
<h4 style="color:darkblue"><u> Mock Function TEST </u></h4>
  <pre>
  
  
  
  </pre>
  
  
</details>
  
  
  
  
  
  
  
  
  
  
  
  
  


<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
  mock / stub -> simulating (replacing) a specific behaviour / state (mock -> replace a specific behaviour) (stup -> replace a specific state)  
  spy -> spying on the behaviour of areal object 
  
  
  
  jest.fn(fn)  
      - creates a mock function 
  jest.mock(modulePath)
      - mocks the module 
      - so once the module is mocked we can use mockFn methods on it
  
  
  
  mockFn.mock
      - property holds the mock functions parameters (how many times it was called, returned value, etc...)
  mockFn.mock.instances 
      - holds the instances when the mock function was instantained 
  mockFn.mock.calls
      - an Array containing all calls with call arguments 
  mockFn.mock.results
      - an Array containing all call resutls 
  
  mockFn.mockReturnValue()
  mockFn.mockReturnValueOnce()
      - specifies the mock function return value (for one time)
  mockFn.mockResolvedValue(returnVal)
      - syntax sugra for 'mockFn.mockImplementation(fn)'
  mockFn.mockImplementation(fn)
      - overrides the mock function 
  mockFn.mockImplementaionOnce(fn)
      - overrides the mock function once 
  mockFn.mockReturnThis()
      - returns the mock's this value 
  mockFn.mockName(name:str)
      - names the mock function 
  mockFn.getMockName()
      - returns the mock function's name 
  mockFn.mockClear()
      - resets all informations in 'mock.calls and mock.instances' -> basically replaces mockFn.mock
  mockFn.mockReset()
      - does what 'mockClear()' but also removes mock returns and implementations 
  mockFn.mockResoter()
      - does what 'mockReset()' does and resets the function before the mocked state
  mockFn.mockImplementation(fn)
      - overrides a mock function or imported class 
  mockFn.mockImplementationOnce(fn)
      - overrides a mock functio for one call only (chainable)
  
  
  
  
  
  
- expect (spy) matchers 
  .toHaveBeenCalled() 
      - the mock function have been called 
  .toHaveBeenCalledTimes(nr)
      - the mock function have been called nr times 
  .toHaveBeenCalledWith(arg, ...)
      - the mock function have been called with these argumenst 
  .toHaveBeenLastCalledWith(arg, ...)
      - the mock function have been called with these argument when it was called for the last time 
  .toHaveBeenNthCalledWith(nthCall, arg, ...)
      - the mock function habe been called with these argument when it was called nth time 
  .toHaveReturned()
      - the mock function returned (not thrown)
      - test if nothing is returned what happesn then 
  .toHaveReturnedTime(nr)
      - the mock function returned nth of times 
  .toHaveReturnedWith(val)
      - the mock function retuned val
  .toHaveLastReturnedWith(val)
      - the mock function lastly returned val
  .toHaveNthReturnedWith(nthCall, val)
      - the mock function returned val at the nth call 
  
  
    mockResolvedValue(mockObj)
  





?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
  - when mocking modules only importe functions are mocked? (other properties are not)
  
  
  
  
-->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2><u> Title 1 </u></h2>
<h2 style="color:darkblue;"> Title 1.1 </h2>
<h3 style="color:darkblue;"> Title 1.1.1 </h3>
<h4 style="color:darkblue;"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>keywords_are_highlighted()</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
