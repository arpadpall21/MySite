<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Data Structures & Algorithms </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Data Structures & Algorithms </h1>
    <p> Updated ( 2021-04-05 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html" title="CSS">Computer Science></a> Data Structures & Algorithms
    </p>
    
    
<table class="table">
<caption>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property / statement ect... </th>
        <th> Description </th>
    </tr>
<tr class="0">
<td> 
            Demo Prop 
</td>
<td> 
            demo description 
            <span class="browserSupport" title="updated : yyyy-mm-dd">
                <span><i class="fab fa-chrome"></i> 0/0 -webkit- </span>
                <span><i class="fab fa-firefox"></i>  </span>
                <span><i class="fab fa-opera"></i>  </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i>  </span>
                <span><i class="fab fa-safari"></i>  </span>
                <span><i class="fab fa-node-js"></i>  </span>
            </span>
</td>
</tr>




</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <h4><u> Tail Recursion [learned about: 2021-04-19] </u></h4>
        <p> - recursive function that never fills the call stack </p>
        <p> - each recursive call has its own internal state, this way no call stack is needed </p>
        <hr>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>

<h2><u> Data Structures </u></h2>
    <p> - way to store data on the computer </p>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Object / Class / Constructor </u></h2>
    <p> - an Object in programming represents something like a car person etc... </p>
    <p> - the Class is a prototype 'bluepirnt', a model from whic we create objects </p>
    <p> - the Constructor creates object based on a Class </p>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Array (time complexity = read <mark>O(1)</mark> / insert <mark>O(n)</mark> / delete <mark>O(n)</mark>) </u></h2>
    <p> - sequentially stored items in memory, array items are indexed therefore they are fast to access </p>
    <p> - arrays cannot be scaled because how the computer memory works, so if we want to scale an array we have to allocate a new array then copy items from the old to the new array </p>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Linked-List (time complexity = read <mark>O(n)</mark> / insert <mark>O(1)</mark> / delete <mark>O(1)</mark>) </u></h2>
<!---------------------------------------------------------------------------------------------------------->
<hr>
    <p> - the linked-list is an Array-like linear data structure where each element has a pointer to the next element  </p>
    <p> - linked-lists are easily scalable but accessing its elements are slow because we have to go throw all elements from the head  </p>
    <p style="text-indent:40px"> - Singly Linked List = each node contain one pointer to the next node (one-way structure) </p>
    <p style="text-indent:40px"> - Doubly Linked List = each node contain two pointers one for the next node one for the previous node  </p>
    <p style="text-indent:40px"> - Circular Linked List = the last node points to the first node (circular) </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    'use strict';
    
    var lList = {                                                                      // this is how the linked list architecture could be implemented in JavaScript 
        data: 'head',
        next: {
            data: 'node-1',
            next: {
                data: 'node-2',
                next: null
            }
        }
    }
        
    class LinkedList{                                                                  // implements linked-list architecture 
        constructor(headData){                                                         // instance created with the 'head' node 
            this.data = headData;
            this.next = null;
        }
        
        add(data){
            let nodes = this.length()
            let ref = 'this.next';
            for(let i = 0; i &lt; nodes - 1; i++){
                ref += '.next';
            }
            eval(ref + '= {data:data, next:null}');
        }
        
        length(){
            let ref = 'this.next';
            let count = 1;
            while (eval(ref)) {
                ref += '.next';
                count++
            } 
            return count
        }
        
        clear(){
            this.data = null;
            this.next = null;
        }
        
        get(index = 0){
            if (index >= this.length()) return 'out of range!';
            let ref = 'this';
            for(let i = 0; i &lt; index; i++){
                ref += '.next';
            }
            return eval(ref + '.data');
        }
    }
    
    
    var myList = new LinkedList('head');                                               // linked-list instance when created (head node)
        
    myList.add('node-1');                                                              // adding additional nodes 
    myList.add('node-2');
        
    console.log( myList.length() );                                                    // -> 3         // linked-list has 3 nodes 
    console.log( myList.get(1) );                                                      // -> 'node-1'  // data of the 2nd node (1st index)  
        
    console.log( myList );                                                             // -> {data:'head', next:{data:'node-1',next:{data:'node-2', next:null}}}
                                                                                       // this is who the linked-list looks like currently   
        
    myList.clear();                                                                    // crears the whole list 
    console.log( myList.length() );                                                    // -> 1         // the 'head' node never removed 
    console.log( myList.get(0) );                                                      // -> null      // but but has no data after the list was cleared 
    
    console.log( myList );                                                             // -> {data:null, next:null}
    </pre>
</details>
<details class="example">
<summary> Example:  </summary>
<h4 style="color:darkblue;"><u> Linke-List implemented in JavaScript TEST </u></h4>
    <pre>
    var linkedList = {
        head: {
            data: 'head',
            next: {
                data: 'node-1',
                next: {
                    data: 'node-2',
                    next: {
                        data: 'node-3',
                        next: null
                    }
                }
            }
        }
    }
    
    console.log( linkedList.head.next.data );                                          // -> 'node-1'
    console.log( linkedList.head.next.next.next.data );                                // -> 'node-3'    
    </pre>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h4 style="color:darkblue;"><u> Linked-List implemented in JavaScript TEST-2 </u></h4>
    <pre>
    class Node{
        constructor(data, next){
            this.data = data;
            this.next = next;
        }
    }
    
    var node3 = new Node('node-3', null);
    var node2 = new Node('node-2', node3);
    var node1 = new Node('node-1', node2);
    var head = new Node('head', node1);
    
    console.log( head.data );                                                          // -> 'head'
    console.log( head.next.next.data );                                                // -> 'node-2'
    </pre>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h4 style="color:darkblue;"><u> Linked-List implemented in JavaScript TEST-3 </u></h4>
    <pre>
    'use strict';
    
    var lList = {                                                                      // this is how the linked list architecture could be implemented in JavaScript 
        data: 'head',
        next: {
            data: 'node-1',
            next: {
                data: 'node-2',
                next: null
            }
        }
    }
        
    class LinkedList{                                                                  // implements linked-list architecture 
        constructor(headData){                                                         // instance created with the 'head' node 
            this.data = headData;
            this.next = null;
        }
        
        add(data){
            let nodes = this.length()
            let ref = 'this.next';
            for(let i = 0; i &lt; nodes - 1; i++){
                ref += '.next';
            }
            eval(ref + '= {data:data, next:null}');
        }
        
        length(){
            let ref = 'this.next';
            let count = 1;
            while (eval(ref)) {
                ref += '.next';
                count++
            } 
            return count
        }
        
        clear(){
            this.data = null;
            this.next = null;
        }
        
        get(index = 0){
            if (index >= this.length()) return 'out of range!';
            let ref = 'this';
            for(let i = 0; i &lt; index; i++){
                ref += '.next';
            }
            return eval(ref + '.data');
        }
    }
    
    
    var myList = new LinkedList('head');                                               // linked-list instance when created (head node)
        
    myList.add('node-1');                                                              // adding additional nodes 
    myList.add('node-2');
        
    console.log( myList.length() );                                                    // -> 3         // linked-list has 3 nodes 
    console.log( myList.get(1) );                                                      // -> 'node-1'  // data of the 2nd node (1st index)  
        
    console.log( myList );                                                             // -> {data:'head', next:{data:'node-1',next:{data:'node-2', next:null}}}
                                                                                       // this is who the linked-list looks like currently   
        
    myList.clear();                                                                    // crears the whole list 
    console.log( myList.length() );                                                    // -> 1         // the 'head' node never removed 
    console.log( myList.get(0) );                                                      // -> null      // but but has no data after the list was cleared 
    
    console.log( myList );                                                             // -> {data:null, next:null}
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Stack / Queue / Double Ended Queue (Deque) </u></h2>
    <p> - all these data structures store their itmes in an array, but the way we access itmes where things differ </p>
    <p style="text-indent:40px;"> - Stack (LiFo = Last in First out) the most recently added item gets out first </p>
    <p style="text-indent:40px;"> - Queue (FiFo = First in First out) the first item gets out first (item which is at the begining of the queue) </p>
    <p style="text-indent:40px;"> - Deque combines Stack and Queue itmes are accessible on both side of the Deque </p>
<details class="example">
<summary> DEMO  </summary>
<h4 style="color:darkblue;"><u> Stack TEST </u></h4>
    <pre>
    'use strict';
            
    class Stack extends Array{  
        add(data){
            this[this.length] = data;
        }
        
        get(){
            return this[this.length - 1];
        }
        
        clear(){
            let length = this.length;
            for(let i = 0; i &lt; length; i++){
                this.pop();
            }
            return length;
        }
    }
    
    var myStack = new Stack();                                                         // stack created 
    
    myStack.add(21);                                                                   // adding new elements to the stack 
    myStack.add(true);                                                                 // any data type can be added to the stack (this is JavaScript baby :)
    myStack.add({p1:'someVal'});
    
    myStack.get();                                                                     // -> {p1:'someVal'}        // the last added value gets out first 
    myStack.add([1, 2, 3]);
    myStack.get();                                                                     // -> [1, 2, 3]
    
    myStack.length;                                                                    // -> 4                     // number of stack element 
                                                                                       // this method is inherited from the Array super class (prototype of the Stack class)
    
    myStack;                                                                           // -> [21, true, {p1:'someVal'}, [1, 2, 3]]    
                                                                                       // this is how the stack looks like currently    
    
    myStack.pop();                                                                     // -> [1, 2, 3]             // removes and returns the last added element 
    myStack.pop();                                                                     // -> {p1: 'someVal'}
                                                                                       // this method is also inherited from the Array super class 
                                                    
    myStack;                                                                           // -> [21, true]
                                                                                       // this is how the stack looks like currently    
    
    myStack.clear();                                                                   // -> 2                     // clears the stack and returns the number of removed elements
    
    myStack;                                                                           // -> []
                                                                                       // this is how the stack looks like currently (empty)
    </pre>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h4 style="color:darkblue;"><u> Queue TEST </u></h4>
    <pre>
    'use strict';
            
    class Queue extends Array{  
        add(data){
            this[this.length] = data;
        }
        
        get(){
            return this[0];
        }
        
        clear(){
            let length = this.length;
            for(let i = 0; i &lt; length; i++){
                this.pop();
            }
            return length;
        }
    }
    
    
    var myQueue = new Queue();                                                         // queue created 
        
    myQueue.add(21);                                                                   // adding new elements to the queue 
    myQueue.add(true);                                                                 // any data type can be added to the queue (this is JavaScript baby :)
    myQueue.add({p1:'someVal'});
    myQueue.add([1, 2, 3]);
        
    myQueue.get();                                                                     // -> 21                    // returns the first element in the queue (does not remove it)
        
    myQueue.length;                                                                    // -> 3                     // number of stack elements 
                                                                                       // this method is inherited from the Array super class (prototype of the Stack class)
        
    myQueue;                                                                           // -> [21, true, {p1:'someVal'}, [1, 2, 3]]    
                                                                                       // this is how the queue looks like currently    
    
    myQueue.shift();                                                                   // -> 21                    // removes and returns the first element in the queue
    myQueue.shift();                                                                   // -> {p1: 'someVal'}
                                                                                       // this method is also inherited from the Array super class 
    
    myQueue;                                                                           // -> [{p1:'someVal'}, [1, 2, 3]]
                                                                                       // this is how the queue looks like currently   
    
    myQueue.clear();                                                                   // -> 2                     // clears the queue and returns the number of removed elements
    
    myQueue;                                                                           // -> []
                                                                                       // this is how the queu looks like currently (empty)
    </pre>
<h4 style="color:darkblue;"><u> Deque (Double-Ended Queue) TEST </u></h4>
    <pre>
    'use strict';
    
    class Deque extends Array{  
        addFirst(data){
            this.unshift(data);
        }
        
        addLast(data){
            this[this.length] = data;
        }
        
        getFirst(){
            return this[0];
        }
        
        getLast(){
            return this[this.length - 1]
        }
        
        clear(){
            let length = this.length;
            for(let i = 0; i &lt; length; i++){
                this.pop();
            }
            return length;
        }
    }
    
    
    var myDeque = new Deque();                                                         // deque created 
        
    myDeque.addFirst(21);                                                              // adding new elements in the front of the deque (any data type can be added)
    myDeque.addFirst(true);  
        
    myDeque;                                                                           // -> [true, 21]
                                                                                       // this is how the deque looks like currently 
        
    myDeque.addLast([1, 2, 3]);                                                        // adding new elements at the end of the deque   
    myDeque.addLast({p1:'someVal'});  
        
    myDeque.length;                                                                    // -> 4                 // number of deque elements 
                                                                                       // this method is inherited from the Array super class (prototype of Deque class)  
        
    myDeque;                                                                           // -> [true, 21, [1, 2, 3], {p1:'someVal'}]  
                                                                                       // this is how the deque looks like currently  
        
    myDeque.getFirst();                                                                // -> true              // returns the first element of the deque (does not remove it)
    myDeque.getLast();                                                                 // -> {p1:'someVal'}    // returns the last element of the deque (does not remove it)
        
    myDeque.shift();                                                                   // -> true              // returns and removes the first element of the deque 
    myDeque.pop();                                                                     // -> {p1:'someVal'}    // returns and removes the first element of the deque 
                                                                                       // these methods are inherited from the Array super class (prototype of Deque class)  
        
    myDeque;                                                                           // -> [21, [1, 2, 3]]  
                                                                                       // this is how the deque looks like currently  
        
    myDeque.clear();                                                                   // -> 2                 // clears the deque and returns the number of removed elements  
    myDeque;                                                                           // -> []                // deque empty 
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Hash Tables (Hash Maps, Dictionaries, Associative Arrays) </u></h2>
    <p> - <b>Dictionary</b> is a key/value data structure (like Objest in JavaScript) </p>
    <p> - <b>Hash Tables</b> is a way to implement a dictionary where accessing the data is fast </p>
    <p> - in a Hash Table we store itmes in an array in key/value pairs </p>
    <p> - we implement a 'hash' function which takes a key and computes a number from it, this number will be the index of the stored item </p>
    <p> - when we want to retrieve the value the key is computed again and the data is looked at the computed index in the array (this is why accessing this data structure is fast) </p>
    <p> - collision : the 'hash' function will compute the same number from different key this is where we have to decide how to handle the collision </p>
        <p style="text-indent: 40px;"> - linear probing = we keep checking for free right next available cells </p>
        <p style="text-indent: 40px;"> - chaining = each array cell contains a linked-list which holds the same computed key/value pairs </p>
        <p style="text-indent: 40px;"> - double hasing = is basically linear probing with different steps </p>
<details class="example">
<summary> DEMO </summary>
    <p> - hash_map.js </p>
    <pre>
module.exports = class HashTable {
    constructor(arrSize = 10){
        this.table = new Array(arrSize);
        this.nrOfItmes = 0;
        this.autoScale = true;                                                         // autoscale can be disabled 
    }
    
    getItem(key){
        let keyIndex = getKeyIndex(key, this.table.length);
        let currentIndex = keyIndex;
        
        for(let i = 0; i &lt; this.table.length; i++){
            if(!this.table[currentIndex]){
                return undefined;                                                      // undefined for non existing keys 
            }
            else if( key == this.table[currentIndex][0]){
                return this.table[currentIndex][1];                                    // return the value of a found key 
            } else {
                currentIndex++;
                if (currentIndex >= this.table.length) currentIndex = 0;
            }
        }
    }
        
    setItem(key, val, arr = this.table){ 
        let keyIndex = getKeyIndex(key, arr.length);
        
        if (arr[keyIndex]) {                                                           // collision handling (linear probing)                
            let currentIndex = keyIndex;
            let nextIndex = keyIndex + 1;
            if (nextIndex >= arr.length) nextIndex = 0;
            
            for(let i = 0; i &lt; arr.length; i++){
                if (key == arr[currentIndex][0]) {                                     // check for same keys    
                    arr[currentIndex] = [key, val];
                    return `[${key}] key set`;
                    
                } else if(!arr[nextIndex]) {                                           // check for the next empty cell 
                    arr[nextIndex] = [key, val];
                    this.nrOfItmes++;
                    
                    if (this.autoScale && this.nrOfItmes > arr.length / 100 * 80) this.resize();
                    
                    return `[${key}] key set`;
                    
                } else {
                    if (this.nrOfItmes >= arr.length) {
                        throw new Error(`hash table full -> [${key}] key not set!`);
                    } 
                    
                    nextIndex++;                                                       // increment next cell counters 
                    currentIndex++;
                    
                    if (nextIndex >= arr.length) nextIndex = 0;                        // prevents array length offset 
                    if (currentIndex >= arr.length) currentIndex = 0;        
                }
            }
        } else {
            arr[keyIndex] = [key, val];
            this.nrOfItmes++;
            
            if (this.autoScale && this.nrOfItmes > arr.length / 100 * 80) this.resize();
            
            return `[${key}] key set`;
        }
    }
        
    removeItem(key){
        let keyIndex = getKeyIndex(key, this.table.length);
        let currentIndex = keyIndex;
        
        for(let i = 0; i &lt; this.table.length; i++){
            if(!this.table[currentIndex]){
                return false;                                                          // returns false if no key found 
            }
            else if( key == this.table[currentIndex][0]){
                this.table[currentIndex] = undefined;
                this.nrOfItmes--;
                return true;                                                           // returns true on successful delete  
            } else {
                currentIndex++;
                if (currentIndex >= this.table.length) currentIndex = 0;
            }
        }
    }
    
    resize(cells){                                                                     // scales up 20% the hash table (by default)
        this.nrOfItmes = 0;
        let _20perc = Math.round(this.table.length / 100 * 20);
        let newArray;
        
        
        if(cells){
            newArray = new Array(this.table.length + cells);
        } else {
            newArray = new Array(this.table.length + _20perc);
        }
        
        this.table.forEach(function(val){
            this.setItem(val[0], val[1], newArray)                
        }, this);
        
        this.table = newArray;
        return true;
    }
            
        state(){
            return {items:this.nrOfItmes, totalSize:this.table.length, autoScale:this.autoScale};
    }}
    
    function getKeyIndex(key, arrLength){                                              // hash function (calculates an index from a key) 
        let asciiCodeSum = 0;
        for(let i = 0; i &lt; key.length; i++){
            asciiCodeSum += key.charCodeAt(i)
        }
        return asciiCodeSum % arrLength;                                               // returned number always lower than the array length 
    }
    </pre>
    <p> - test.js </p>
    <pre>
    var HashTable = require('./hash_map.js');
    
    var myTable = new HashTable();                                                     // allocates a 10 item array (default) 
    // var myTable = new HashTable(100);                                               // would allocates a 100 item array  
    
// get / set items --------------------------------------------------------------------
    myTable.setItem('Franky', {age:40, sex:'M'}); 
    myTable.setItem('Franky', {age:42, sex:'M'});                                      // overwrites the existing key value 
    myTable.setItem('Judy', {age:25, sex:'F'}); 
    myTable.setItem('Bob', {age:32, sex:'M'}); 
    
    myTable.getItem('Bob');                                                            // -> {age:32, sex'M'}
    myTable.getItem('Judy');                                                           // -> {age:25, sex'F'}
    myTable.getItem('Mary');                                                           // -> undefined             
    
    myTable.state();                                                                   // -> {items:3, totalSize:10, autoScale:true}
                                                                                           // hash map has 3 items 
                                                                                           // internal array size 10
                                                                                           // autoscale on
    
// remove item ------------------------------------------------------------------------
    myTable.removeItem('Bob');                                                        // -> true          // item successfully removed 
    myTable.removeItem('Mary');                                                       // -> false         // no such key exist  
    
    myTable.state();                                                                  // -> {items:2, totalSize:10, autoScale:true}
    
// internal array scaling -------------------------------------------------------------
    myTable.setItem('Jeny', {age:18, sex:'F'}); 
    myTable.setItem('Stacy', {age:18, sex:'F'});    
    myTable.setItem('Erica', {age:17, sex:'F'}); 
    myTable.setItem('Stephanie', {age:19, sex:'F'}); 
    myTable.setItem('July', {age:21, sex:'F'}); 
    myTable.setItem('Rebeca', {age:20, sex:'F'}); 
    
    myTable.state();                                                                   // -> {items:8, totalSize:10, autoScale:true}
                                                                                
    // by default the autoscale is on so when the internal array is 80% full a new 20% larger array is automatically allocated  
    myTable.setItem('Antonia', {age:19, sex:'F'}); 
    
    myTable.state();                                                                   // -> {items:9, totalSize:12, autoScale:true}
                                                                                         // the new array is 20% larger (totalSize:12)
    
    myTable.resize(8);                                                                 // internal array can be manually scaled (8 cell added)
    myTable.state();                                                                   // -> {items:9, totalSize:20, autoScale:true}
                                                                                         // the new array size 20 (totalSize:20)
    
    myTable.autoScale = false;                                                         // autoscale can be disabled 
    myTable.state();                                                                   // -> {items:9, totalSize:20, autoScale:false}
                                                                                         // autoscale disabled
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Graph </u></h2>
    <p> - collection of vertexes (nodes) with edges (links) between them (like a network) </p>
    <p> - edges can be directed (one way) or undirected (two ways) </p>
    <img src="./weighted VS Unweighted Graph.png" height="150">
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Tree </u></h2>
    <p> - the tree data structure is a graph type datastructure, it's an upside down tree where there's a root element on the top (the root node is reachable from anywhere in the tree) </p>
    <p> - child nodes have childs nodes further down and so on..., (in a Binary Tree each node can have up to 2 child nodes (left and right child node)) </p>
    <p> - no 2 references allowed to the same node! </p>
<details class="example">
<summary> DEMO  </summary>
    <pre>
    var root = {                                                                       // binary tree data structure 
        data: 2, 
        left: {
            data: 3,
            left: {
                data: 7,
                left: null,
                right: {
                    data: 10,
                    left: null,
                    right: null
                }
            },
            right: {
                data: 9,
                left: null,
                right: {
                    data: 1,
                    left: null,
                    right: {
                        data: 13,
                        left: null,
                        rigth: null
                    }
                }
            }
        },
        right: {
            data: 5,
            left: null,
            right:null
        }
    }
    
    function treeSum(node){                                                            // adds all node values in the tree (recursively)
        if (node == null) return 0;
        return node.data + treeSum(node.left) + treeSum(node.right);
    }
    
    treeSum(root);                                                                     // -> 50
    </pre>
</details>
<details class="example">
<summary> Example:  </summary>
    <pre>
    var root = {                                                                       // binary tree data structure 
        data: 2, 
        left: {
            data: 3,
            left: {
                data: 7,
                left: null,
                right: {
                    data: 10,
                    left: null,
                    right: null
                }
            },
            right: {
                data: 9,
                left: null,
                right: {
                    data: 1,
                    left: null,
                    right: {
                        data: 13,
                        left: null,
                        rigth: null
                    }
                }
            }
        },
        right: {
            data: 5,
            left: null,
            right:null
        }
    }
    
    function treeSum(node){                                                            // adds all node values in the tree (recursively)
        if (node == null) return 0;
        return node.data + treeSum(node.left) + treeSum(node.right);
    }
    
    console.log( treeSum(root) );                                                      // -> 50
    </pre>
</details>






<br><br><br><br><br><br>
<br><br><br><br><br><br>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2><u> Algorithms </u></h2>
    <p> - a set of instructions on a data structure for accomplishing a task </p>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Linear Search (time complexity = <mark>O(n)</mark>) </u></h2>
    <p> - the linear search can be performed on an unsorted array </p>
    <p> - we check each elements down the list basically </p>
<details class="example">
<summary> Example:  </summary>
    <pre>
    function linearSerach(arr, key){
        for(let i = 0; i &lt; arr.length; i++){
            if (arr[i][0] == key) return arr[i][1];
        }
        return -1;
    }
    
    var arr = [['apple', 2], ['plum', 1], ['pear',3]]
    
    console.log( linearSerach(arr, 'apple') );                                         // -> 2
    console.log( linearSerach(arr, 'plum') );                                          // -> 1
    console.log( linearSerach(arr, 'orange') );                                        // -> -1    
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Binary Search (time complexity = <mark>O(log n)</mark> / <mark>O(1)</mark>) </u></h2>
    <p> - the binary search is performed on a sorted array </p>
    <p> - we divide the array by 2 and check if the serached value is smaller or larger than the middle value, this procedure is repeted recursively untill the serached value is found </p>
<details class="example">
<summary> Example:  </summary>
<h4 style="color:darkblue;"><u> - Binary Search TEST </u></h4>
    <pre>
    var arr = [-45, -21, -14, -5, 0, 1, 9, 41, 65, 122, 540, 666, 1024, 5487, 51487, 32548];        // sorted Array  
    
    function binSearch(arr, target){
        var left = 0;
        var right = arr.length -1;
        
        while (left &lt;= right) {
            let mid = Math.floor((left + right) / 2);
            if (arr[mid] == target) {
                return mid;                                                            // match returned 
            } else if (target &lt; arr[mid]) {
                right = mid - 1;                                                       // if the target is in the left part of the searching field we move the right pointer    
            } else {
                left = mid + 1                                                         // if the target is in the right part of the searching field we move the left pointer    
            }
        }
        return -1;                                                                     // if no match found -1 returned 
    }
    
    console.log( binSearch(arr, -14) );                                                // -> 2
    console.log( binSearch(arr, 122) );                                                // -> 9
    console.log( binSearch(arr, 555) );                                                // -> -1
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Selection Sort (time complexity = <mark>O(n^2)</mark>) </u></h2>
    <p> - selection sort is used to sort array elements in ascending order </p>
    <p> - we check each element and compare it against all the remaining elements in the array, (for each check the leftmost element will be swapped to be the smallest), this process is repeaded untill all elements are checked </p>
<details class="example">
<summary> DEMO  </summary>
    <pre>
    var myArray = [4, 2, 6, 51, -4, -2, 0, 1, 21, 74, 101, -55, 21];
    
    function selectionsort(arr){
        for(let i = 0; i &lt; arr.length; i++){
            let minIdx = i; 
            
            for(let k = i + 1; k &lt; arr.length; k++){                                   // we only check the number of elements what left (counted from the current min index)
                if (arr[i] > arr[k]){
                    let temp = arr[i];                                                 // if the checked element is smaller we swap (becomes the current min index)
                    arr[i] = arr[k];
                    arr[k] = temp;
                }
            }
        }
        return arr
    }
    
    selectionsort(myArray);                                                            // -> [-55, -4, -2,  0,  1,  2, 4,  6, 21, 21, 51, 74, 101]
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Merge Sort (time complexity = <mark>O(n log n)</mark>) </u></h2>
    <p> - merge sort is used to sort array elements in ascending order </p>
    <p> - we implement a 'merge' function a temporary array is used, in this arary  we copy all itmes from the original array </p>
    <p> - then split the temporary array in 2 parts (left, right), then check each parts from left-to-right </p>
    <p> - where the value is smaller that value will be copied back to the the original array </p>
    <p> - a parent function recursively splits by to the original array, the from the bottom when only 2 elements are we start calling the 'merge' function to merge sort </p>
<details class="example">
<summary> DEMO  </summary>
    <pre>
    function merge(arr, leftIdx = 0, rightIdx = arr.length -1){ 
        let temp = new Array(rightIdx - leftIdx + 1);                                  // at each merge a temporary array is allocated = little bit memory hungry :(  
        let tempLeftIdx = leftIdx;
        
        for(let i = 0; i &lt; temp.length; i++){
            temp[i] = arr[tempLeftIdx];
            arr[tempLeftIdx] = undefined;
            tempLeftIdx++
        }
            
        let mid = Math.floor(temp.length / 2);
        let l = 0;
        let r = mid;
        
        let partLength = rightIdx - leftIdx;
        for(let i = 0; i &lt; partLength + 1; i++){
            if (l == mid){
                arr[leftIdx] = temp[r];
                r++;
            } else if (temp[r] == undefined){
                arr[leftIdx] = temp[l];
                l++
            } else if (temp[l] &lt; temp[r]) {    
                arr[leftIdx] = temp[l];
                l++
            } else { 
                arr[leftIdx] = temp[r]
                r++
            }
            leftIdx++;
        }
        return arr;
    }
    
    function mergeSort(arr, leftIndex = 0, rightIndex = arr.length -1){                // recursively splits the array by 2 
        if(leftIndex == rightIndex) return arr;
        
        let mid = rightIndex - Math.floor((rightIndex - leftIndex) / 2);
        
        mergeSort(arr, leftIndex, mid - 1);
        mergeSort(arr, mid, rightIndex);
        
        merge(arr, leftIndex, rightIndex);                                             // merge starts from the bottom to up = merge sort 
        
        return arr;
    }
    
    var arr1 = [-1, 10];
    console.log( mergeSort(arr1) );                                                    // -> [-1, 10]
    
    var arr2 = [4, -4, 7, 1];
    console.log( mergeSort(arr2) );                                                    // -> [-4, 1, 4, 7]
    
    var arr3 = [6, 5, 4, 3, 2, 1]; 
    console.log( mergeSort(arr3) );                                                    // -> [1, 2, 3, 4, 5, 6]
    
    var arr4 = [0, 5, 7, -4, 1, 0, 21, 11, 0, 2, 21]; 
    console.log( mergeSort(arr4) );                                                    // -> [-4, 0, 0,  0,  1, 2, 5, 7, 11, 21, 21]
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Quick Sort (time complexity = <mark>O(n log n)</mark> / <mark>O(n^2)</mark> </u></h2>
    <p> - quicksort is used to sort array elements in ascending order </p>
    <p> - for this we implement a 'partition' function which divides and swap array elements into 3 parts...</p>
    <p style="text-indent:40px;"> 1) the pivot element (arbitrary element)</p>
    <p style="text-indent:40px;"> 2) left side of the pivot elements are smaller (or equal) than the pivot </p>
    <p style="text-indent:40px;"> 3) right side of the pivot elements are larger (or equal) than the pivot </p>
    <p> - the goal of the 'partition' function is to swap the pivot element in the right ascending index</p>
    <p> - now we recursively call the 'partition' function one each side of the pivot until the whole array is sotred </p>
<details class="example">
<summary> DEMO  </summary>
<h4 style="color:darkblue;"><u> Quick Sort TEST </u></h4>
    <pre>
    var arr1 = [321, 2];
    var arr2 = [3, -2, -1, 0, 33];
    var arr3 = [3, -2, -1, 0, 2, 4, 1];
    var arr4 = [-2, 1, 2, 1, -4, 10, -75, 0, 1, 3, 8, 45, 2];
    var arr5 = [100, 4987, -4165, 48, -47, -8, 0, 0, 11, 145, 55, 55, 4878, 55, 55];
    var arr6 = [100, 4987, -4165, 48, -47, -8, 0, 0, 11, 145, 55, 55, 4878, 55, 55, 654, -8457, 1, 3485, 2, 21];
    
    function quickSort(arr){
        qs(arr, 0, arr.length - 1);
    }
    
    function qs(arr, l ,r){
        if (l >= r) return;                                                            // condition ends the recursive call 
        var p = partition(arr, l, r);
        
        qs(arr, l, p - 1);                                                             // recursively calls the partition function 
        qs(arr, p + 1, r);
    }
    
    function partition(arr, l, r){                                                     // partition function sorts the array in 3 parts                            
        var pivot = arr[r];                                                                // 1) we chose an arbitrary pivot (the last array item in this case)    
        var i = l - 1;                                                                     // 2) items left to the pivot are smaller (or equal) than the pivot     
        var j = l;                                                                         // 3) items right to the pivot are larger (or equal) than the pivot     
        
        for(let k = 0; k &lt; r - l; k++){ 
            if (arr[j] &lt; pivot){
                i++;
                let temp = arr[i]; 
                arr[i] = arr[j];
                arr[j] = temp;
                j++;
            } else {
                j++;
            }
        }
        arr[r] = arr[i + 1];
        arr[i + 1] = pivot;
        
        return i + 1
    }
    
    quickSort(arr1);
    arr1;                                                                              // -> [2, 321]
    
    quickSort(arr2); 
    arr2;                                                                              // -> [-2, -1, 0, 3, 33]
    
    quickSort(arr3); 
    arr3;                                                                              // -> [-2, -1, 0, 1, 2, 3, 4]
    
    quickSort(arr4);
    arr4;                                                                              // -> [-75, -4, -2, 0, 1, 1, 1, 2, 2, 3, 8, 10, 45]
    
    quickSort(arr5);
    arr5;                                                                              // -> [-4165, -47, -8, 0, 0, 11, 48, 55, 55, 55, 55, 100, 145, 4878, 4987]
    
    quickSort(arr6);
    arr6;                                                                              // -> [-8457, -4165, -47, -8, 0, 0, 1, 2, 11, 21, 48, 55, 55, 55, 55, 100, 145, 654, 3485, 4878, 4987]
    </pre>
</details>
<details class="example">
<summary> Example:  </summary>
<h4 style="color:darkblue;"><u> Quick Sort TEST </u></h4>
    <pre>
    var arr1 = [321, 2];
    var arr2 = [3, -2, -1, 0, 33];
    var arr3 = [3, -2, -1, 0, 2, 4, 1];
    var arr4 = [-2, 1, 2, 1, -4, 10, -75, 0, 1, 3, 8, 45, 2];
    var arr5 = [100, 4987, -4165, 48, -47, -8, 0, 0, 11, 145, 55, 55, 4878, 55, 55];
    var arr6 = [100, 4987, -4165, 48, -47, -8, 0, 0, 11, 145, 55, 55, 4878, 55, 55, 654, -8457, 1, 3485, 2, 21];
    
    function quickSort(arr){
        qs(arr, 0, arr.length - 1);
    }
    
    function qs(arr, l ,r){
        if (l >= r) return;                                                            // condition ends the recursive call 
        var p = partition(arr, l, r);
        
        qs(arr, l, p - 1);                                                             // recursively calls the partition function 
        qs(arr, p + 1, r);
    }
    
    function partition(arr, l, r){                                                     // partition function sorts the array in 3 parts                            
        var pivot = arr[r];                                                                // 1) we chose an arbitrary pivot (the last array item in this case)    
        var i = l - 1;                                                                     // 2) items left to the pivot are smaller (or equal) than the pivot     
        var j = l;                                                                         // 3) items right to the pivot are larger (or equal) than the pivot     
        
        for(let k = 0; k &lt; r - l; k++){ 
            if (arr[j] &lt; pivot){
                i++;
                let temp = arr[i]; 
                arr[i] = arr[j];
                arr[j] = temp;
                j++;
            } else {
                j++;
            }
        }
        arr[r] = arr[i + 1];
        arr[i + 1] = pivot;
        
        return i + 1
    }
    
    quickSort(arr1);
    console.log( arr1 );                                                               // -> [2, 321]
    
    quickSort(arr2); 
    console.log( arr2 );                                                               // -> [-2, -1, 0, 3, 33]
    
    quickSort(arr3); 
    console.log( arr3 );                                                               // -> [-2, -1, 0, 1, 2, 3, 4]
    
    quickSort(arr4);
    console.log( arr4 );                                                               // -> [-75, -4, -2, 0, 1, 1, 1, 2, 2, 3, 8, 10, 45]
    
    quickSort(arr5);
    console.log( arr5 );                                                               // -> [-4165, -47, -8, 0, 0, 11, 48, 55, 55, 55, 55, 100, 145, 4878, 4987]
    
    quickSort(arr6);
    console.log( arr6 );                                                               // -> [-8457, -4165, -47, -8, 0, 0, 1, 2, 11, 21, 48, 55, 55, 55, 55, 100, 145, 654, 3485, 4878, 4987]
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Breadth-First-Search (time complexity = <mark>O(V + E)</mark> (verticles (vertex) + edges)) </u></h2>
<h2 style="color:darkblue;"><u> Depth-First-Search (time complexity = <mark>O(V + E)</mark> (verticles (vertex) + edges)) </u></h2>
    <p> - Breadth First Search and Depth First Search is used to find a vertex in an unweighted graph or tree data structure </p>
    <p> - <b><u>Breadth-First Search</u></b> </p>
    <p style="text-indent: 40px;"> - searches closest nodes to the starting point first, therefore it finds the shortes route <u>(in segments)</u> to the target vertex  </p>
    <p style="text-indent: 40px;"> - searches the neighbours of the start node (1st level) then searches these neighbours neighbours (2nd level) and so on until the target is found </p>
    <p style="text-indent: 40px;"> - for this uses an internal queue data structure to keep track what has to be checked next (nodes added at the end of the queue, starts checking from the start of the queue) </p>
    <p> - <b><u>Depth-First Search</u></b> </p>
    <p style="text-indent: 40px;"> - searches farthest nodes from the starting point first then comes closer and closer to the starting node on the graph until the target is found </p>
    <p style="text-indent: 40px;"> - for this uses an internal stack data structure to keep track what has to be checked next (if the current node is not the target and all its neighbours are checked we next check the node what is on the top of the stack) </p>
<details class="example">
<summary> DEMO  </summary>
    <p> - Breadth-First Search </p>
    <pre>
    var map = {                                                                        // graph data structure 
        me : {edges:['bob', 'alice', 'claire']},
        bob : {edges:['anuj', 'peggy', 'me']},
        alice : {edges:['peggy', 'me']},
        claire : {edges:['me', 'jonny', 'thom']},
        peggy : {edges:['bob', 'alice']},
        jonny : {edges:['claire']},
        anuj : {edges:['bob']},
        thom : {edges:['claire', 'steven']},
        steven : {edges:['thom', 'henry']},
        henry : {edges:['steven']}
    }
    
    function bfs(graph, start, target, getRoute){
        if (!graph[start]) {
            let errMsg = `no "${start}" node exist on the network`
            throw new Error(errMsg);
        }
        
        let queue = [];
        let queuePointer = 0;
        let traceTree = {};
        graph[start].checked = true;
        let found = checkNeighbours(graph, start, target, queue, traceTree) ;
        
        while(!found && queuePointer &lt; queue.length){ 
            found = checkNeighbours(graph, queue[queuePointer], target, queue, traceTree);
            queuePointer++;
        }
        
        for (let i in graph){                                                          // at the end each node checked status is reset (for the next check) 
            graph[i].checked = false;
        }
        
        if (getRoute && found) {
            return buildRoute(traceTree, target);
        }
        
        return found;
    }
    
    
    function checkNeighbours(graph, node, target, queue, tree){                        // returns true if target is a neighbour of the passed 'node' 
        graph[node].checked = true;                                                    // marking the currently node as checked 
        tree[node] = [];
        
        for(let i = 0; i &lt; graph[node].edges.length; i++){
            if (target == graph[node].edges[i]) {
                tree[node].push(target)
                return true;
            }
            
            if (!graph[graph[node].edges[i]].checked) {                                // if the node was already checked it won't be added to the queue  
                queue.push(graph[node].edges[i]); 
                
                tree[node].push(graph[node].edges[i]);                                 // builds a tree data structure representing possible routes 
            } 
            
            graph[graph[node].edges[i]].checked = true;                                // mark the checked node
        }
        
        return false                                                                   // returns false if target is not a neighbour of the passed 'node' 
    }
    
    
// route tracing functions ------------------------------------------------------------ 
    function buildRoute(tree, target){                                                 // retraces from target to start = builds the route 
        let route = []
        route.unshift(target)
        
        for(let i in tree){
            if (getParent(tree, route[0])) {
                route.unshift( getParent(tree, route[0]) );
            }
        }
        
        return route
    }
    
    
    function getParent(tree, child){                                                   // helper function return the parent in the trace tree data structure 
        let parent;
        
        for(let i in tree){
            tree[i].forEach(function(val){
                if(val == child) {
                    parent = i;
                }
            });
        } 
        
        return parent;  
    }
    
    bfs(map, 'me', 'alice');                                                           // -> true
    bfs(map, 'me', 'alice', true);                                                     // -> ['me', 'alice]
    
    bfs(map, 'anuj', 'alice');                                                         // -> true
    bfs(map, 'anuj', 'alice', true);                                                   // -> ['anuj', 'bob', 'peggy', 'alice']
    
    bfs(map, 'anuj', 'henry');                                                         // -> true 
    bfs(map, 'anuj', 'henry', true);                                                   // -> ['anuj', 'bob', 'me', 'claire', 'thom', 'steven', 'henry']
    
    bfs(map, 'claire', 'franky');                                                      // -> false 
    bfs(map, 'claire', 'franky', true);                                                // -> false 
    
    bfs(map, 'franky', 'bob');                                                         // -> error thrown "no 'franky' node exist on network 









    </pre>
    <p> - Depth-First Search </p>
    <pre>
    var map = {                                                                        // undirected graph 
        me : {edges:['bob', 'alice', 'claire']},
        bob : {edges:['anuj', 'peggy', 'me']},
        alice : {edges:['peggy', 'me']},
        claire : {edges:['me', 'jonny', 'thom']},
        peggy : {edges:['bob', 'alice', 'polly']},
        polly : {edges:['peggy']},
        jonny : {edges:['claire']},
        anuj : {edges:['bob']},
        thom : {edges:['claire', 'steven']},
        steven : {edges:['thom', 'henry']},
        henry : {edges:['steven']}
    }

    function dfs(graph, start, target){
        if (!graph[start]) {
            let errMsg = `no "${start}" node exist on the network`
            throw new Error(errMsg);
        }
        
        let nextToCheck = [start];                                                     // array used (not primitive) because primitives in JS are immutable 
        let stack = [];
        let checkNextNeighbour = nextNeighbour(graph, stack, nextToCheck, target);  
        
        while(!checkNextNeighbour && nextToCheck[0] != undefined){
            checkNextNeighbour = nextNeighbour(graph, stack, nextToCheck, target);  
        }
        
        for (let i in graph){
            graph[i].checked = false;
        }
        
        return checkNextNeighbour;
    }


    function nextNeighbour(graph, stack, node, target){
        if (node[0] == target) {
            return true;
        } else {            
            graph[node[0]].checked = true;
            
            for(let i = 0; i &lt; graph[node].edges.length; i++){ 
                if (!graph[graph[node[0]].edges[i]].checked){
                    stack.push(node[0]);
                    node[0] = graph[node[0]].edges[i];
                    
                    return false;
                } 
                
            }
            
            node[0] = stack.pop();
            return false;
        }
    }


    console.log( dfs(map, 'me', 'alice') );                                            // -> true
    console.log( dfs(map, 'anuj', 'alice') );                                          // -> true
    console.log( dfs(map, 'anuj', 'henry') );                                          // -> true 
    console.log( dfs(map, 'polly', 'steven') );                                        // -> true 
    console.log( dfs(map, 'claire', 'franky') );                                       // -> false 
    console.log( dfs(map, 'franky', 'bob') );                                          // -> error thrown "no 'franky' node exist on network  
    </pre>
</details>
<!---------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Dijkstra's Algorithms (djkszr) (time complexity = <mark>O(E log V)</mark> (edges LOG verticles)) </u></h2>
    <p> - Dijkstra's Algorithm is used to find the shortest path to all nodes on a weighted graph data structure <u>(it does not work if the graph has any negative weights)</u> </p>
    <p> - at the start and we map the graph and set up a table (object) with all the nodes and their values as positive Inifnity (starting node set to 0) </p>
    <p> - we mark the starting node as checked and check the weight to its neighbors </p>
    <p> - <b><u>rule 1 :</u></b> we update neighbor nodes' values (in the table) if the newly calculated distance to the neighbor is <u>shorter</u> what's in the table currently </p>
    <p> - <b><u>rule 2 :</u></b> we only check unchecked neighbors </p>
    <p> - <b><u>rule 3 :</u></b> we take all <u>unchecked</u> nodes from the table and we choose the one with the lowest distance to be checked next </p>
    <p> - this pattern is repeated with all nodes untill the whole graph is checked </p>
    <img src="./Dijkstra.gif" height="200">
<details class="example">
<summary> DEMO  </summary>
    <pre>
    var map1 = {
        A: {edges:{B:2, C:6}},
        B: {edges:{A:2, C:3, D:5}},
        C: {edges:{A:6, B:3, D:1}},
        D: {edges:{B:5, C:1}}
    }

    var map2 = {
        A: {edges:{B:2, C:4}},
        B: {edges:{A:2, C:1, E:2, D:7}},
        C: {edges:{A:4, B:1, D:3, E:3}},
        D: {edges:{B:7, C:3, E:2, F:1}},
        E: {edges:{C:3, B:2, D:2, F:5}},
        F: {edges:{D:1, E:5}}
    }

    var map3 = {
        A: {edges:{B:1, C:2, X:5}},
        B: {edges:{A:1, C:5, E:4, D:7}},
        C: {edges:{A:2, B:5, D:8, E:0, X:3}},
        D: {edges:{B:7, C:8, E:3, F:7, Y:2}},
        E: {edges:{C:0, B:4, D:3, F:9, X:1}},
        F: {edges:{D:7, E:9}},
        Y: {edges:{D:2}},
        X: {edges:{A:5, C:3, E:1}}
    }
    
    
    function dijkstra(graph, start, target){
        let cost = {} 
        let result = {}
        let nrOfNodes = 0;
        
        for(let i in graph){
            nrOfNodes++;
            result[i] = {cost:Infinity, parent:''};
            
            if (i == start) {
                cost[i] = 0;
            } else {
                cost[i] = Infinity;
            }
        }
        
        for(let i = 0; i &lt; nrOfNodes; i++){
            prevParent = checkNode(graph, cost, result);
        }
        
        for(let i in graph){
            graph[i].checked = false;
        }
        
        return buildRoute(result, target, nrOfNodes);
    }
    
    
    function checkNode(graph, cost, result){
        let chpNode = '';
        let nodeVal = Infinity;
        
        for (let i in cost){
            if (cost[i] &lt; nodeVal) {
                chpNode = i;
                nodeVal = cost[i];
            }
        }
        
        graph[chpNode].checked = true;
        result[chpNode].cost = cost[chpNode];
        
        for(let i in graph[chpNode].edges){
            if (!graph[i].checked) {
                if (cost[i] > cost[chpNode] + graph[chpNode].edges[i]){                // if the newly calculated route is shorter we update!
                    cost[i] = graph[chpNode].edges[i] + cost[chpNode];
                    result[i].parent = chpNode;                                        // only update the parent if shorter route is found 
                } 
            }
        }
        
        delete cost[chpNode];
    }
    
    
    function buildRoute(result, target, nrOfNodes){
        let routes = {}
        
        for(let i in result){
            if (target !== true) i = target;
            
            let route = {cost:result[i].cost, route:[]};
        
            let check = i;
            let parent = result[i].parent;
            
            route.route.unshift(check);
            
            while(parent !== ''){
                route.route.unshift(parent)
                check = parent;
                parent = result[check].parent        
            }
            
            if (target !== true) return route;
            
            routes[i] = route;
        }
        
        return routes;
    }
    
    // map1 --------------------------------------------
    // shortest route from A to D 
    console.log( dijkstra(map1, 'A', 'D') );                                           // -> { cost: 6, route: [ 'A', 'B', 'C', 'D' ] }
    // shortest route from A to all possible nodes 
    console.log( dijkstra(map1, 'A', true) );                                          // -> { A: { cost: 0, route: [ 'A' ] },
                                                                                       //      B: { cost: 2, route: [ 'A', 'B' ] },
                                                                                       //      C: { cost: 5, route: [ 'A', 'B', 'C' ] },
                                                                                       //      D: { cost: 6, route: [ 'A', 'B', 'C', 'D' ] }}
    
    // map2 --------------------------------------------
    // shortest route from A to F 
    console.log( dijkstra(map2, 'A', 'F') );                                           // -> { cost: 7, route: [ 'A', 'B', 'C', 'D', 'F' ] }
    // shortest route from A to all possible nodes 
    console.log( dijkstra(map2, 'A', true) );                                          // -> { A: { cost: 0, route: [ 'A' ] },
                                                                                       //      B: { cost: 2, route: [ 'A', 'B' ] },
                                                                                       //      C: { cost: 3, route: [ 'A', 'B', 'C' ] },
                                                                                       //      D: { cost: 6, route: [ 'A', 'B', 'C', 'D' ] },
                                                                                       //      E: { cost: 4, route: [ 'A', 'B', 'E' ] },
                                                                                       //      F: { cost: 7, route: [ 'A', 'B', 'C', 'D', 'F' ] }}
        
    // map3 --------------------------------------------
    // shortest route from A to F 
    console.log( dijkstra(map3, 'A', 'F') );                                           // -> { cost: 11, route: [ 'A', 'C', 'E', 'F' ] }
    // shortest route from A to all possible nodes 
    console.log( dijkstra(map3, 'A', true) );                                          // -> { A: { cost: 0, route: [ 'A' ] },
                                                                                       //      B: { cost: 1, route: [ 'A', 'B' ] },
                                                                                       //      C: { cost: 2, route: [ 'A', 'C' ] },
                                                                                       //      D: { cost: 5, route: [ 'A', 'C', 'E', 'D' ] },
                                                                                       //      E: { cost: 2, route: [ 'A', 'C', 'E' ] },
                                                                                       //      F: { cost: 11, route: [ 'A', 'C', 'E', 'F' ] },
                                                                                       //      Y: { cost: 7, route: [ 'A', 'C', 'E', 'D', 'Y' ] },
                                                                                       //      X: { cost: 3, route: [ 'A', 'C', 'E', 'X' ] }}
    </pre>
</details>

<!--
    - finds the shortest route in a weighted graph for all verticles 
    - set the initial distance to Infinity to all nodes at start (if at the end Inifnity stays that means that node is unreachable!)
    - next best (cheapest weighted) key value pair 
    - does not work if the graph has any negative weights
    
    
    - Bellman-Ford algorithm 
-->




<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
    
    
    - Big O notation (runtime complexity) O(n) = (n number of operations) (a big 'O' = Operations)
        - describes the performance of an algorithm (aproximate measure (some more or less operation doesn't really count))
            - O(1) = algorithm runs in constant time (same time taken regardless of the input size )
                time complexity: constant time 
            - O(log n) = logarithmic groth = algorithm is more scalable 
            - O(n) = linear groth (the size of the data is in direct relation with the algorithm performance) 
                time complexity: linear time
            - O(n * log n) 
            - O(n^2) = quadratic time = algorithm is slower with larger data 
                time complexity: quadratic time 
            - O(2^n) = exponential groth 
            - O(n!) = factorial 
        - time takes to run your function <- size of the input 
        - how the function scales when the input gets bigger and bigger 
        - the big O notation always describes the worst case of an algorithm 
        - it's an approximation, ex: the constant (time to take one operation) is not measured 
    
    
    
    - Dijkstra's algorithm (djkszr)
    - knapsap problem 
    
    - in programming log alwasy means log2 (logarithm base 2)
        
    
        
    
    
    
    
    - vertext (verticles) describes a point in 2D or 3D 
    - n + n  ->  2n
    - load factor (how full is a storage) = number of elements / total available space (expressed as 0.1 = 10% full / 1 = 100% full )
---------------------------------------------------------------------------------------------
"Documents/CodePlus/My Site/Computer Science/Data Structures & Algorithms"
---------------------------------------------------------------------------------------------
    
    
?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????


-->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2><u> Title 1 </u></h2>
<h2 style="color:darkblue;"> Title 1.1 </h2>
<h3 style="color:darkblue;"> Title 1.1.1 </h3>
<h4 style="color:darkblue;"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>keywords_are_highlighted()</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
</body>
</html>
