<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Timers </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Timers (ver 3.2) </h1>
    <p> Updated ( 2019-07-24 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Node.js></a> Timers  
    </p>
<table class="table">
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr>
        <td colspan="2"> Timers </td>
    <tr>
        <td> clearImmediate(<strong>immediate:obj</strong>) </td>
        <td> cancels the immediate timer referenced by the <mark>immediate</mark> object
            <span id="browserSupport" title="updated : yyyy-mm-dd">
                <span><i class="fab fa-node-js"></i> 0.9.1 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> clearInterval(<strong>timeout:obj</strong>) </td>
        <td> cancels the interval timer referenced by the <mark>timeout</mark> object
            <span id="browserSupport" title="updated : yyyy-mm-dd">
                <span><i class="fab fa-node-js"></i> 0.0.1 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> clearTimeout(<strong>timeout:obj</strong>) </td>
        <td> cancels the timeout timer referenced by the <mark>timeout</mark> object
            <span id="browserSupport" title="updated : yyyy-mm-dd">
                <span><i class="fab fa-node-js"></i> 0.0.1 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> setImmediate(<strong>fn</strong><i>, arg, ...</i>) </td>
        <td> - calls the callback function immediately after the main thread and after any I/O event callbacks<br>
             - returns <u>a unique <mark>Immediate</mark> object</u> which is used to control <u>this</u> timer 
            <span id="browserSupport" title="updated : 2019-07-29">
                <span><i class="fab fa-node-js"></i> 0.9.1 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> setInterval(<strong>fn</strong>, <strong>delayMs:nr</strong><i>, arg, ...</i>) </td>
        <td> - calls the callback function every set time (<strong>delayMs:nr</strong>)<br>
             - returns <u>a unique <mark>Timeout</mark> object</u> which is used to control <u>this</u> timer 
            <span id="browserSupport" title="updated : yyyy-mm-dd">
                <span><i class="fab fa-node-js"></i> 0.0.1 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> setTimeout(<strong>fn</strong>, <strong>delayMs:nr</strong><i>, arg, ...</i>) </td>
        <td> - calls the callback function after the specified time (<strong>delayMs:nr</strong>)<br>
             - returns <u>a unique <mark>Timeout</mark> object</u> which is used to control <u>this</u> timer
            <span id="browserSupport" title="updated : yyyy-mm-dd">
                <span><i class="fab fa-node-js"></i> 0.0.1 </span>
            </span>
        </td>
    </tr>
    <tr> 
        <td colspan="2"> timer control methods </td>
    </tr>
    <tr>
        <td> 
            <strong>immediate</strong>.hasRef()<br>
            <strong>timeout</strong>.hasRef()
        </td>
        <td> returns <mark>true</mark> it the timer is attached (referenced) to the Node.js event loop otherwise returns <mark>false</mark>
            <span id="browserSupport" title="updated : 2019-07-30">
                <span><i class="fab fa-node-js"></i> 11.0.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> 
            <strong>immediate</strong>.ref() <br>
            <strong>timeout</strong>.ref()
        </td>
        <td> - reattaches (references) the timer back to the event loop so the Node.js process will wait till this timer ends <br>
             - returns the <mark>Immediate</mark> | <mark>Timeout</mark> object 
            <span id="browserSupport" title="updated : 2019-07-30">
                <span><i class="fab fa-node-js"></i> 0.9.1 <mark>timeout</mark></span>
                <span><i class="fab fa-node-js"></i> 9.7.0 <mark>immediate</mark></span>
            </span>
        </td>
    </tr>
    <tr>
        <td> <strong>timeout</strong>.refresh() </td>
        <td> - restarts the timer counted from this method's execution <br>
             - restarts an already expired timer <br>
             - returns the <mark>Timeout</mark> object
            <span id="browserSupport" title="updated : 2019-07-30">
                <span><i class="fab fa-node-js"></i> 10.2.0 </span>
            </span>
        </td>
    </tr>
    <tr>
        <td> 
            <strong>immediate</strong>.unref()<br>
            <strong>timeout</strong>.unref()
        </td>
        <td> - removes (unreferences) the timer from the event loop so the Node.js process can exit without waiting to this timer <br>
             - returns the <mark>Immediate</mark> | <mark>Timeout</mark> object <br>
             - creates an internal timer that will wake the Node.js envent loop <u>(this silet timer can affect the performance)</u> [TESTED: 2019-07-30 (but I couldn't confirm this behavior)]
            <span id="browserSupport" title="updated : 2019-07-30">
                <span><i class="fab fa-node-js"></i> 0.9.1 <mark>timeout</mark></span>
                <span><i class="fab fa-node-js"></i> 9.7.0 <mark>immediate</mark></span>
            </span>
        </td>
    </tr>
</table>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
    <p> - we can use <mark>util.promisify()</mark> on timers [NOT TESTED : 2019-07-29] </p>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://nodejs.org/dist/latest-v12.x/docs/api/timers.html" target="_blank"> Node.js Timers </a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - Node.js timer counter starts as soon as the timer statement is executed (not after the main thread) but the callback function is still executed after the main thread</p> 
    <p> - <mark>unRef()</mark>-ed (removed timer from the event loop) still execute its callback (this is what says in Node.js specification) but I cannot Test this [TESTED : 2019-07-30] </p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the Node.js timer API provides a mechanism to schedule function calls in the future </p> 
    <p> - unlike in the browser in Node.js timers are built around the event loop </p>
    <p> - Node.js does not guarantee the exact timing nor the the execution order of timer callbacks, but executes as close as possible to the specified time </p>
<h2><u> Timers <mark>setImmediate()</mark> / <mark>setTimeout()</mark> / <mark>setInterval()</mark> / <mark>clearImmediate()</mark> / <mark>clearTimeout()</mark> / <mark>clearInterval()</mark> </u></h2>
        <p> - Node.js timer counter starts as soon as the timer statement is executed (not after the main thread) but the callback function is still executed after the main thread</p> 
    <pre class="syntax">
SYNTAX :    setImmediate(<strong>fn</strong><i>, arg, ...</i>)                                          // calls the callback function immediately after the main thread and after any I/O event callbacks, returns <u>a unique <mark>Immediate</mark> object</u> which is used to control <u>this</u> timer   
            setTimeout(<strong>fn</strong>, <strong>delayMs:nr</strong><i>, arg, ...</i>)                                // calls the callback function after the specified time (<strong>delayMs:nr</strong>), returns <u>a unique <mark>Timeout</mark> object</u> which is used to control <u>this</u> timer   
            setInterval(<strong>fn</strong>, <strong>delayMs:nr</strong><i>, arg, ...</i>)                               // calls the callback function every set time (<strong>delayMs:nr</strong>), returns <u>a unique <mark>Timeout</mark> object</u> which is used to control <u>this</u> timer
                - <strong>delayMs:nr</strong> : time specified in <u>milliseconds</u> (from <mark>1</mark> to <mark>2147483647</mark>, if the time is specified out of this range = <mark>1</mark>)
                - <i>arg, ...</i> : arguments to pass to the callback function   
    
            clearImmediate(<strong>immediate:obj</strong>)                                       // cancels the immediate timer referenced by the <mark>immediate</mark> object   
            clearTimeout(<strong>timeout:obj</strong>)                                           // cancels the timeout timer referenced by the <mark>timeout</mark> object   
            clearInterval(<strong>timeout:obj</strong>)                                          // cancels the interval timer referenced by the <mark>timeout</mark> object   
    </pre>
    <pre>
// setImmediate() / clearImmediate() -------------------------------------------
    var immediate = setImmediate(() => {});                                     // callback function immediately called after the main thread  
    var immediate2 = setImmediate(() => {});
    
    clearImmediate(immediate);                                                  // -! the returned 'Immediate' obects are uniqe so this cancels only the first timer   
    
// setTimeout() / clearTimeout() -----------------------------------------------
    var timeout = setTimeout(() => {}, 1500);                                   // callback function is called after 1500 milliseconds (1 and a half second)   
    
    clearTimeout(timeout);                                                      // cancels the timeout timer   
    
// setInterval() / clearInteral() ----------------------------------------------
    var interval = setInterval(() => {}, 1500);                                 // callback function is called every 1500 milliseconds (1 and a half second)
    
    clearInterval(interval);                                                    // cancels the interval timer 
    // clearTimeout(interval);                                                  // -! this would do the same as the 'clearInterval()' above (so basically they do the same thing)   
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>setImmediate()</mark> / <mark>clearImmediate()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    setImmediate( () => {console.log( '1- setImmediate() called' );} );
    var immediate2 = setImmediate( () => {console.log( '2- setImmediate() called' );} );    // the returned 'Immediate' object referenced here in order to cancel this immediate timer later 
    setImmediate( () => {console.log( '3- setImmediate() called' );} );
    
    clearImmediate(immediate2);                                                 // we clear (cancel) the second immediate timer her 
    
    console.log( 'end of module' );    
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\01 setImmediate() clearImmediate() TEST> node main
        end of module                                                           // immediate timers are called after the main thread 
        1- setImmediate() called                                                
        3- setImmediate() called                                                // immediate timers are called in the order 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\01 setImmediate() clearImmediate() TEST>    
    </pre>
<hr>
<!--------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>setTimeout()</mark> / <mark>clearTimeout()</mark> / <mark>setInterval()</mark> / <mark>clearInterval()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    var interval = setInterval(() => {                                          // called every half second
        console.log( 'interval called' );
    }, 500);
    
    global.setTimeout(() => {                                                   // called after 5 seconds 
        clearInterval(interval);                                                // cancels the 'setInterval()' above 
    }, 5000);
    
    var timeout = setTimeout(function(){                    
        console.log( 'timeout called' );
    }, 0);                                                                      // timer set to '1' milliseconds by node because '0' is out of range 
    
    clearTimeout(timeout);                                                      // cancelling timout timer 
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\02 setTimeout() clearTimeout() setInterval() clearInterval TEST> node main
        interval called
        interval called
        interval called
        interval called
        interval called
        interval called
        interval called
        interval called
        interval called
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\02 setTimeout() clearTimeout() setInterval() clearInterval TEST>    
    </pre>
<hr>
<!--------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> timer start time count TEST </u></h4>     
    <p> - Node.js timer counter starts as soon as the timer statement is executed (not after the main thread) but the callback function is still executed after the main thread</p> 
    <pre style="margin-bottom:1px;">
    global.setTimeout(function(){                                               // -! timer is counter from this statement but the callback is executed after the main thread 
        console.log( 'timeout called!' );
    }, 1000);
    
    for(let i = 0; i &lt; 100000; i++) {
        console.count('TEST');
    }    
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\03 timer start time count TEST>    
        TEST: 1...
        TEST: 100000
        timeout called!                                                         // called right after because the timeout counter is NOT counter from the end of the main thread and by the main thread is finished the 1 second is already elapsed!   
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\03 timer start time count TEST>    
    </pre>
</details>
<hr>
<!--------------------------------------------------------------------------------------------------------------------->
<h2><u> Methods <mark>unref()</mark> / <mark>ref()</mark> / <mark>hasRef()</mark> / <mark>refresh()</mark> </u></h2>
    <pre class="syntax">
SYNTAX :    <strong>immediate</strong>.unref()                                                   // removes (unreferences) the timer from the event loop so the Node.js process can exit without waiting to this timer    
            <strong>timeout</strong>.unref()                                                        returns the <mark>Immediate</mark> | <mark>Timeout</mark> object
                                                                                   creates an internal timer that will wake the Node.js envent loop <u>(this silet timer can affect the performance)</u> [NOT TESTED : 2019-07-30 (I couldn't figure out how to test)]   
            
            <strong>immediate</strong>.ref()                                                     // reataches (references) the timer back to the event loop so the Node.js process will wait till this timer ends 
            <strong>timeout</strong>.ref()                                                          returns the <mark>Immediate</mark> | <mark>Timeout</mark> object 
 
            <strong>immediate</strong>.hasRef()                                                  // returns <mark>true</mark> it the timer is attached (referenced) to the Node.js event loop otherwise returns <mark>false</mark>
            <strong>timeout</strong>.hasRef()
            
            <strong>timeout</strong>.refresh()                                                   // restarts the timer counted from this method's execution             
                                                                                   restarts an already expired timer    
                                                                                   returns the <mark>Timeout</mark> object 
    </pre>
    <pre>
    var timeout = setTimeout(function(){ }, 5000);
    
// unRef() / ref() / hasRef() --------------------------------------------------
    timeout.hasRef();                                                           // -> true              // by default all timers are referenced to the Node.js event loop       
    
    timeout.unref();                                                            // -> Timeout {}        // removes (unreferences) the timer from the event loop and returns the timer object   
    timeout.hasRef();                                                           // -> false             // this confirms that the timer is removed from the event loop   
    
    timeout.ref();                                                              // -> Timeout {}        // reataches (references) the timer to the event loop and returns the timer object   
    timeout.hasRef();                                                           // -> true              // this confirms that the timer is in the event loop again 
    
// refresh() -------------------------------------------------------------------
    timeout.refresh();                                                          // -> Timeout {}        // the 5 seconds are basically restarted here (if the timer would be expired by now this would reactivate it)   
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> <mark>unref()</mark> / <mark>ref()</mark> / <mark>hasRef()</mark> TEST </u></h4>
    <p style="color:yellow;"> - the unreferenced callback is executed (this is what says in Node.js specification), but I cannot get any feedback to confirm this in this in this test! </p>
    <pre style="margin-bottom:1px;">
    var timeout1 = setTimeout(() => { console.log('timeout-1 fired!') }, 1);
    var timeout2 = setTimeout(() => { console.log('timeout-2 fired!') }, 2000);
    var timeout3 = setTimeout(() => { console.log('timeout-3 fired!') }, 4000); // !! this callback is executed after Node is closed because it is unRef()-ed but I cannot confirm this!   
    
    timeout1.unref();                                                           // 1st and 3rd timeouts are unRef()-ed  
    timeout2.unref();
    timeout2.ref();                                                             // 2nd timeout unRef()-ed and ref()-ed back here 
    timeout3.unref();
    
    console.log( "Timeout-1 referenced to event loop = " + timeout1.hasRef() );
    console.log( "Timeout-2 referenced to event loop = " + timeout2.hasRef() );
    console.log( "Timeout-3 referenced to event loop = " + timeout3.hasRef() );
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\04 unref() ref() hasRef() TEST> node main
        Timeout-1 referenced to event loop = false
        Timeout-2 referenced to event loop = true
        Timeout-3 referenced to event loop = false
        timeout-1 fired!                                                        // unRef()-ed timer callback called here  
        timeout-2 fired!
                                                                                // -! I never see the 3rd timeout callback because Node is closed by than   
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\04 unref() ref() hasRef() TEST>    
    </pre>
<hr>
<!--------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>refresh()</mark> TEST </u></h4>
    <pre style="margin-bottom:1px;">
    var timeout = setTimeout(function(){
        console.log( 'timeout executed!' );
    }, 1000);
    
    setTimeout(function(){
        timeout.refresh();
    }, 3000);
    
    setTimeout(function(){
        timeout.refresh();                                                      // -! for some reason this last timer's call does not refreshes the original timeout   
    }, 5000);    
    </pre>
    <pre class="cmd" style="margin-top:1px;">
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\05 refresh() TEST> node main
        timeout executed!
        timeout executed!                                                       // timer restarted 
    PS D:\safe\code +\my site\03 improuve\learn webdesign\04 node.js\timers\05 refresh() TEST>    
    </pre>
</details>
    
    <br><br>
</body>
</html>